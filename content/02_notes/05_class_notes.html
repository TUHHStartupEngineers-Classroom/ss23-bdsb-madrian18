<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"e05128a389b3339cbe85770bd40cc6b7502732ff803c8b29beda867af23692b4ddce6b16ce4e4a9845fda7c96d08f8bac1bfd5c17ff8afaede4d1c429d52317bad28a7261e0509b0bf6db98c7f2111408beec4bdf16a706e85c9426f0946ac22c2d499c3036b12286f842de53ee0c2f9bdf6cce62c781041a5e5057ecee63d780f94a4547334689c6fdf5bac6279e0b4d0545fdf4bf454c0a55260118d2cc4d7c2ee7da1c3125339b95c07a3e599a97d2ab09049af120fa691ce89804a4ebf8f519cc4e078c70a3365e69579dbdb09f016eb38cd67bdf670727a4dfdf40ab26d867aa9e60b8ccac3c1f3dc897f14c6248fe4b69206d042eb78afd710f2d7a56245832c62330d23cb4f74e64a6c5e5cd00a56b0ad93bd272e23857fa5566b87a4c6bcd5d188cd9d3c26cac174c5b4e731fc636a19c24174a63d5657487991a582174794fdbce779144e65a551f4f3a518d6309390f88e932fe3ace2ca2049e062f191ec37de37ec683ff221e9ec6d3d61c15d4240f408cfcb80caf50e661d030a6c1c6c53efcacd4cc075cc5c005adf26f1615ca02239c9b7f41f667a923fe78ac6ca3205607b72cb0b21221a4c9267b405e947b3862ee6f37c27f83aa153aaab8143c2d12110f329056f47006c9dd0e8e22f60e1a891d8d240c881ee0523e3acdee3c475034a097832e3164e2f5758159be666fdce27fb14143078e4ad304e749791e20a87ff238d5fa40528d483c9dd2429848e73d433aa7c521e222e8556d4679bd3778d43664d61020d68a9517ee5a032eb76a32fbe5caf4d979c77cf7734eaa70e7c2535d71c497934496ae3c797e0e5a6df67d9238f033d925dd2557488858cac7e9fd485fe5b0959d9984681d7fc5f262b0cc7159ccc7d1e2fd77109309a05397e54a04c241c9d6277b115baa64ac2992913d925e37bf1669dc1a5529a1ad57a2881f875056128f0d01b41a18befc70fb951110233135272a0be89b98d9e95d8d93a8659a0aa8768273d55f9b12bd7a8fd30ed44c9e14f257f582c63aecf0080da000a5233151accb2fbcad665b7edec48eeb098fda44aabf7cd809e114043664cf584fafda9b38b4b8680d7eb7d2c104d7abe5f6224956b10427e8cbdf18099353e027896d7f8e1efd1605e516fe767c44c06a253ce765da1ab41290ee8d3a44c223f16923d8dd965727331c7538aea29283c3ea89bc960c5ffe872e18902c893c8443ce53901db40fd5e574c81cbbc1af2f11b2bbc5d936553015c957c80158ed87974a5efd6d0f87709947b608072772491bad2d92af69410dbc9a0785aacfd6bb28e56440b3835a6c0522493d60698cb56412f6428dd2812dec29027b5f7885c3781071e787da29ee6dc18af29452df6da893ba1a814e8072d7a874079f5a4b7f219b244c7ea5d1f2e24adf3f793efe7cda2710f3a8ab3db41c73ea9b9018247143395db04767b14d30219e2eded61ad234c9f8cf5b745be828fc7d1f57a0f4c945dc5bd36f0aeb69d42ef90edaf567108ea32e30713872e4ea36f8c9007187eee5ad79401529f19b679f39c4d9668058acc586c30631d95af7258326a233cbbd8e246093a2da7b489b6ef3eadf3f2a0ee8d5e18133599925bcf6b14770d292bb2735081bf72f98939818d2b2c0c29e4f58b4235af601ccecba980baa23a446336852e92e3a964468f4df7d36cb517237c298765ca869f65eaf602c76eb163a8ce55a06c4faf8dfcda3d96a0568b5e11e65a247eb47f14cc1f880e827c7c4cf24ee544dc7c49c546c5af17f095d65551e1c114710fcf47d2d25736dc1f6cd65dd16f48764e2253d232a28ba64a3c0357b628521d4c19329a049f91696d45afd19417ec70eb6f98be29d041e5ecb28b970178a1f29d6ac1a307011a0394c7a4d9f7505b76fffc2649638b0ea564663a5871af2d3be7026dae30f16b81d8788ae2caa85521f6f94542bcaf6874219e7e67fa619c54b29d8902541a4cd94e49259153f9e792d68865924a16cbb38f2d11f89e60fd9a835b74fabc5ab7466b5aaf814b3c51bfe59750204142be5988b5f9a3d6386a11c5229d549d1c9b878590b404e6fe5f2719d99a2ef65ca20c94270081c2cc5024b2eb14607b33b082db64b067dabc80e1641674adf0ddd766ae01a4aa9ab669d17a5bea1d002af5387b94c916295c9b802e1b4dbea4fd3e1620a15ee8d4c442ccc39713c39c12909aebb9af2c50bd62af5145739a6bd9cc53c0957237cedd3b72172d46e54e9d643c04efb4d9bb6309a333f279709d25b5480fd13bdf737a42fdaaba49623faa998a37fcd10c2842a69701ffb483fe00341a310f2aecd7e2e262579e1632f53552cbdd471311eba31f7f5ef9cc9061fbade9d68a5ba6f75dec2ae94b2db2bee109e81eeeeb339faad02793ea3c35568adfb24432e4a386a89cb733afaf4ee59a1539f13c64169012ee1ba1adf5912dc68c964bc05e49db3fd42ec4f82a1127e41d236e45c1e928ce19991fd432d8e0e43fac4b55c2f92eafad3d8bdd22e18e5d1cc8bfdf0e600fcaae5d43e395007b689cd3d0ab65517caf46cfb1b74ba4020a20a1014a6c5feabfab6bf44a73ae118dfae3506bc02a6a3b7beb2dcf3b143cb3b7e129548deb72be1beb74a122a242bf1abeadf52ba80ce95ad388553ee8378d5d463dc8bb2c585ab6a8decfed0fb13b3e8f92c7b6eb439d7930ec2e119a54ad4eadf6b1e25ba36042ca5709fb8375ac70340077820dfb1552d9c7d4b9c7b03d0dbdc8215493f4f65c704048186279c1971d6f5845914f7b0f68ed9f5361fcf8b25db0a1e1531bbc2b9b401b1818c5e05c1e1ee9f4e6fa1ac5ab722ba159e9399d8ca53599ec450770200d61359e6c5987c5bd863289da0daecf32d890400ee27dd21545a6b66d1077dfde260cf42a955c5eb8626bf6beb5ddb82598736a9b93fa2ee4a06f3e69e279548169f1a93be7bde6104f797e38ecbd007744cdd1dc5291d3a35bbc14fd3ad7993c05633ac3b1acbb5fc63e5f433dbcb905024fc41c638794f4a7c0eb240986b141908383eb7a92d12817945f94d868c1e3cdebf4a03a6d29723ae5a5fc2070e2ceeeeef0aa73d4085431d07b4e9a86ff567f8d98ded26cf03037ce7d67862511dbf3ed3227a639d138a840b23dd30e570a5527a1e2f6c19a2e23ffc5f06afb7c2a9bc7d84652f55cfa7e99c88e7bbbd9238647474af69cbb45f3c9b6ec4ce6ad4d76fc39291400082ecbea0a34365ef06e3919af61017c13dcdfa371905c70742a4ac71646590e21037c4dfd4313a7b9f2dbd900cf35ad8c056d3f12a1753c0d6610469fa5ee7e0b955f4108c14b93cdffa5cacb6817738c5a551cf065c92de2dbf8dfa0dec20213c359ce42655d2410be2c56df2a3c17fc1f16ac8bb91ccb5052109fe4cc3b67129ddaacf51918b146408351d4dea87e812fc6b6e4cfe267321b837fa6625ab545faa39192fbbbfd13f0cde3d26938c11b0d059d9f34f22bfd8b1a8864633b12a3bc948c1c5206761debaf34821f354437cc3d2c024375d1de3573024995ece3e443f8bb769156408d7f209b2874435e3062c01baf9e6180c445ab9491a1c2f2f685183cdfe72f5ca29d6b0820da57ee1b5e3466e7c896b078bc5cdf778b300f52bccc810b2934cd5c09d11c3b69933d2f579f10693920de54be4559c228fb5049e3a51163d238a6aa888f9d9aebc6cb2fde87e4ccf55aa79a32cfda76d4eb3ee08b83d30b04ba4c4ffa44fd69157e9c4e652e79897c2fc25b176df8826077d56769dd3b2659a8b5e385bc1d459976656a96bfba1b288c636b4692527951872b99e7f7f3c82cac253e434a5a2ad5d27ce9b232ecdff5ffda4b431c432127abc4b17da1d8de21356270d5b13e368c79bbadbcc0160705f6fe4086af74ee47e750372173b5a2a953c465fbc112e03cd35e029eb1e6f5a11df5b16b86897f3576dd6a7c687ce8e8a95f8c4c45928f12eb1dda67f48883a324dd769cf0c6fe67670e9b21ac36064df366ce2ddc3b977ed454054d3db378c5a52a816733ceb016c42e55bc04a9a0c6782d5da4d4421b1d7d23887f46b243fc21647958ff8275190d5856a683708a5cc6e573153a14cbc449521a6688e1374b471d4d9e3cf19a9fb4eb73a5a966547cf0e18016d7f7d1b130a6bfbd31fe44921aec5382fcbcc4debda2f127ec2a9d17eab50d0ef9085329677e59d9b28b9cd7efda7c7c7ef0c1064d1c42957efc4bc696a9edbd00602ae3787b2cbd0c4176afd6c41bb20943fae800a4f9636f9a9d1e23e0161c87cb4aedcd1daf0ec1253b037650035d4d2b7c7f06a1d274dcedaeaaccb631cb67e97d22b4941283d1a32ecacd7e5d27f3e17d01a528387333300670332f81cc0249442dcdc681d6159a03008a7116d175e8038f89e50bcaed39f33a53aca4d6e44639e0eff64c50dbee4e5fcae9889ad309533680cff51d7d52d57a7596cae1286f79f55cd333253938e5fdb60ac1d65b815918fe975606e2eefd2bd82888740ef133fd24b8e1acbfe2c01d28450e9a8c6695b388efca58ead99fe9d046fa6e0cff62bb44b80ee9cddc0c0e96726fe450defbdf8b77def8125e57b9a1efe02d3f241b943d7dab5bbc57f89b4af3ac92d2bf0a7c2aa3822543639638e934ce50e45404edbe741f4422d385e830f61c8dddacc1df8e3b7e781607563a549e3165e587f9e67b148196c90d2ef85a103e026ce235d2dd3e40213035645da1d069b624a485ff6d596c1c20c8a265ae00f790faa7e9106315606355b797519eb366abc0f42c3cd673af1a62d5b9f2edeb26a1571396a4fc6ba7626ab44877a74c751d0ab6e9af86f800a70e8f381842d703f8845b3f1930ec4bb00e417fa6bca47c1e6dff500c06e035708f247472f1153f765423e2792522b977124540f959c0bf8122e576e79329a301683681bb81fdc1bc9e88cb73fe94231f1cef8eb6920166e4b394d2e51b4eee3a1f706e55c9e45a325467a58a170149c079ea3d4998bfd6b7a9536e44b7bcf6090fc27e1526cdba5e90c96ac35bc1a58b5508b7c47bf78c919ec4d11a7a770387880e3292737622a4bbd5d4b1458fbb5f4102795edc1c1e2d119a06ed9384114e0fcf58a75fc24f21787da62ca85d9f3107f1c5126ced90ee1ddf3e5068c619bc66a417920fb758734a4d578c1f2e6525c03e55d91c88fe842fd01d6df41ae8d4fbbbda60fc1c628cfda009059c657617ca31abc34a411859cd57f12dd63f7dd15b9a3ead838d708a2e248579b2a5dea52d6c9d97084d1a2d4afefbfb0dd511bc80a56561dc2aa711dccf5b4616d5a86de2d74e4b4c70d7c0ee53bdb32f6f30823dfe353473d9106942b2c606b855260b2618c7e33851bebaf42a0469e6487eb93a26d42ca790d30878b9bef6593a3b8a38083bf1584bcaf13970cce05441c183f142be625b31732bd6efa32410776711d37f9fd047ffe5cd76f61523b3d111e1e03eca034873e31122fa05bdfb581ba2a53656ee4d1a1d2443503b44dd9ac8c02a538ba0e88579d9d25446b1b8ea97bc585ba3fa40de789aec8376297254ef7ece14101b8b1639c2852399dd6dbd091a214d0e8a1041b473d4b92f960d3d2dab491e6bdccb082bb94651db9df803148a071f250e4c1ddc8d25ea8e8e90b48554d82b6a8f8a8bae8c929538923ab1023ef8046d97b583c408d4e72d33afe2e15049968c87e4dd82499df94a7111a89a663cb7894d8bf09e52a4604cf591061be5a074f2b47d7051182bfb1fb3edfaa6d7767c763e114c1fc8f6c821abdae13b3daa32df5b9a894e17604f97e63e8d8d7cae5d9679ac7ddaf2147e9389113f67dc73712ce010027cf25a4e53fe53755e30a5b882cfd1b25bbb7966452174d470dbffdd96224f78d7be2ef1949ed521682ce804024b85224167e78cb775e8969f3ef94e2eaef95304bba47a367787ee4851b97a126998b936a7fabd681cc4795036d4cbd2509d5a616a73b6d3176e1e5cfd93ac3574442a7d4e585a9965fefbdfdf066fa36cfa252c7cabc5d91397f742008de926836e4e23a88a8e898b7007c4caf3828808e24000a3bf32f48aabaf2f7a1d6c05f66b004d5bc96cc32e54667f960d8cc5b95ec633f334c333ba4dadeebce214bb5b57aa6140a2567e5ed0a5b4a621fb34c9bedc4a46372c5ac4d260f76d9c925b514d8b90c675b1cf6a1715184833f0037db3b27505f496f0c326c88d142c26ab05d1e087ebc469b295d445aa36f52859e720c6155eaaf8f3f661e7c4ae029062592e1fa30a5254cc1afea8bcb1610fc2b92c528f8709ab73a91f5ad81c069f03423733a6e4f7cc3b5486b15bd4b43a34a1ab87540044221c81b72d6605f5918fa8f69f0fbc096a53c2220bb4e3ea46eb2ddbf25435522d4191ca205d39301235b67e7878315935551475cd5aa27a5fecc8980356b627637fc4179ed5241c16804d22ce0b21251d48edb3b7ca925c0203cccb73ad14c498b144d2d95d7c0136f8ce96e407233de98cc60060036d83e0246deadda47371074be4cbcac849a8dc0b379c2ffeb2ae2eddc42e733b6d57abb6a9f6d6572f64361061f7b16fd465587b322e6d50fda052c13864555cfef32aa34b85fdcefa7970fe07f8df33c5f9d16d350663b2fad73c0ac5236d819ff905d00f0d451a5a3d8c0532ec0bb994fb0cdbd3d8a1d34bc670a19e483c793b8102b0b7738b9585c4d6967e48fcc464e9d6c9b77d09983e19632c38eec9d412079fa9b0c85b0320a7949ac94e7170ca3cd5ce4affb1766ef1a3f7888805e7f50f0b1fd0681a904da2bb38929aef480b3714356649ea15f221690e1047b37c6d88d25963330bd6dc2c50af090cd93fe908ac94d7b60ed64071d2d30039934c82d9853b15b7371ee608ae14e7c2973ad1b8560ae7973dc1cc908163c4876ae6200c7b5b5d3345a605ffe807526cfc9fb782dab85ff042fb6010fa1512abb1b3c5225375851912a597001193cf060f40daa310ebfbfae23d0658b8286e0fc0bc08b12d10883e39cce888c5ac0f46c4ce46856a7a861910699e0e1314b7909abeff5935fd298570e6fd350033a281b7c8ba505742da68620f62f73f208307c07b4e4d42dac31adbe407694e3241bc495c98ad3d811712da2227f6477797722246dc686aff4bf8eb836031aab69ad4ff93b148f40f616b58d7e795357e3167a017155b0288761abb2a88b2c9c83d1c01824b9ae6ce313277dcde1e2b0ad029cd41b5ffdfee7efc4906ebd2a10df9657063741a23cd64d3d68bc2f7f5bc7eca7c4fe50cf6486f718d5e449c83e9294e789792b22d7eaf761f663b2aa661b16d73cb9d66ab1366dbf21c80c9e281e36195adbe38b51a0d64f8e8a6c0319342c98ca8d77e777a71820fbdf9a4840269a0070d1f62496f2330f14e27a5ed1e43102e0621e27c6ac90435fb5b63559762f1cce242eb508d1567c6cb87bff587dc647cfe680bc61ab90ed0eab994200bb212195de9cd69a66e94fb028d7a4a89d1f0bfb8f23f9dea011b034cce2254e354874c1fbdba8b2e8f0bb56f472f5c7d766d958ae31c763a105f23213bdd6a0d94899c6997f145ffc91cf698500d79c8e7004373f51074508261da1ceaa54cff836727ba9ebee3a247bb4213e964b90b66a36a2e9a64da8eab8f658ff9b786ceecc7678fdefd2bd7b9cbe8dcc97c452aae915997fbab44da4e1880faf3f273b851e88db4d9680109e46d6463b553577c871d876a24a0ac53d7be85bbb50b3e1df5640e36fe9ab0fb804ada214100880bae4d01f82a0cebff61d7d3943e5cdda65ac199c91df046c77eb7b1c53a86a5d1e8930db6b9762c01c353315701c2cd8ea1ac1b66058bac8daacabd99d19bcbea9d2f186c2e5c6cf1be5300f2a01d68a5b3b5d208773c7d87e6f7027629fafc82aba73acf84b4c7f28d4b76b45b236de248451c22769fc79d6a671a9341b8894b1cc0104d633221a83b540141a19ad5d5c905a11a4e1649c828e8109e0609a56079fc7ff666e92a236acc2a4c63165ed7b62509b851d0c9e796f27c616756f2c08cb198eca4c60812aad99b4d9739d0a9f323fa7a118dbe93e75891b78d2adfd157fc9925285abc4eda41cb7c0d4cbd80196b8163bb4f4b0fab72c285dbfbe12bbf97aeeb0635a4537c8a97688279f3b96bb9e32a1229083598a4e1a9c8f8a56dc191ec53839a1c43d6f76cc7e252eee550e198c3a0ffadab7275f3ce0374e5a103d85baab6ad0542284fdd83f8e1fe4f2876e032931e6e62ce532b63221f2482ba605493bf2add88b4ace9ee6bf3ca38d1700a08f6118ae5072f9aacf2c0065a0c2d1b5b530a3d6b794e89e35c1dd30676f5829a5634f3ed0b41663663ae42b42893e5a24a851b98a3d800791f8ec07f1b3093b182ae231807269c79889ee2f6c63a439766c6b3059cb4959ad47353b6307044de22a259638db8ba2677b8aaa19383cd4b5474af38b5d07dedfd8c0a6b3f8f051b301bbc3fd97d1291bc7e1047fa3340b88db4c4bdeef41bc052b0d127265e5578a27ceede943792cf91188cb0e4c6db61ff019ee81565dea60b06c4f6b387aaa02a71c28619f5fd69ca94266f11a84d28004ced5f90d6ff795d341b30ccfd377cce5d3518b3e3a13a0d0eca9593bb5b88444c81faecd0eca7cf590ef556385b2aa340e9f833b92511a3646c0b9ddd2755dc8a2ac01e1bf01607cbe59d6c555c604d2d160fdb515fb25983a060f769c5c85dba526123eefba938c46c45a6506aa2bdddfab12aa4d58f9c280e0600d3c6aa35050a42331314120001d8b4f6f47f380bd4fb6eb16c9a86b3b65b83c3afe925e87d9cbf22d1ca91c57455af2d741769dc48f44b61d785cc0ae1612b47686e21160c4651c768612cdc7b88be0caaf8b20f19913ce22d49f7d238d1e0e242416f9f967341e5ad781e792b9690eeec98c1381a447913c8db320d580ce7ecab5326bad19fcdbce46a338a1c06748a30fc05937c7a4086db69403f0a7cf75f20ae9e6ba59b3215179f5097034108b2ca279c30a6bb3b59d5741ee4d6fcb70573b3c143a8154e1cb2e022d42ea0991327f69ce34cd277ac903934a7628ed6887251d3e49d5f669bb759e98f9b1fdfa5135836b2f02a58b6397284143b0eace915cbe601c5e84b6a5257eec404e52d8f7371669631665859fdecc2f35fb3d8d239d6c2801f777e03f48b6fb6d1820f05f0f0b7210462a0401708790bd358e267aded1411e7198293df88a09ce8f489dfc047a133f15a80b17b44ef2f67c23063775e418514ad735e95123e7fdb6afad78919566744f31ed062d7f403545e6b9050a8cf73ca746166b853295052cfdf463e50b951e7143405635f646ff88915a35162042e0dceca8a117c0b1e33bad33ebb64371435a563740144e362562e3317db690067271fc968d843416b92dc4b1f53c499b7ec6288353a3ace831e6944355f73cce0761e4f6c42b5e64c80d20f99a86feb0687e287a0287d0a6374c2eb03aa7e1c60bac97472fb33d3209e1dba3c7964ff6a337d9a1c6c5dd6e12cec629ff46bb2bd6b94c6e0a3d1d6375ff275a2e331d93cd10f89114965d47b2c641bcf7a7973b1eb3f71c8e5baab09c8d62475c6f2a91153d0fdfb61bce63eb0ecd2191e17ec404e40f50d0465eca475a8abfcf25554b55ea0e020898262073584bc8c438faf29d66e6aa8a4cde7bd200f37cef94c2aa43b0b6e95251bb3bf7cc283ec5d5de719a1d3f575eaefdf577144acccdaf8cee60b7364534fb8b9d973610f2e572ad107f231b450ec83599d497fc301326a2de576c2bc4fda63c4d9a0c9fef3197bc3a26d83c4755538781677d5d80333d7daa17862e5665dbe47d3d25829371fccaa3fff6ab08357aaa9240a6f9978d7bd3678fd7738bf8a5b4671199bc872aa005fdee3c53f45e54bb87d4849f5c400cd6113c6905855339cf3814a7aa730d36120d0857e801cee47e4c1a0cda122fb190cfabc56070c8a0db0d0894d695a7908ee631d7723829056d6377a7f2453ecf127338bd4eba9fa73d0b201c49a04e0015a51967b3be3f31e54a80999b85d16a740f57f422af50e8d54191df9ee4b71b377c4b63bd5d06634521dd2a45e256836126eb43155c7ec4e62552e3c603a779c434b98d866c33cdd95dd30e5f3d2a3af6216bdeea7ae2a28d875114f512ec225f8480ba3dd8f80ba39c7b2039a0e16cdffdc9c92ebbd4e5d8e810798c44e483d23fc8a2360240328444ea21516a9121e035001d14ab7bdef3d5ef918c7358643490b88c596a613c855036f4a2821ce3a987b5f5008e810ac6347110c3c360c994e8e930e1528f2a78be190ac16ade09ddebf61716f8f1fe04e6b7672327f1de0d8a9029149a755991cf134731cba752093b217dd8e28cfadfc07ee64a93c2a04f5c3145b42309fba31e096d0dc2b50f21f4d783aabf9c1b819f944578b661d0c6417acdfd220c73e10c1eb564404a057eeb8fb1fafb28bcb1a128d00b2d4e50c686189f95de2c7a8b486efdb1e785ecc8903949d55b534ef1ce854743a8aea8a7648b00eaf54029606a8323ce01d936817d4d4d8a5c89e87763b0d26f112f13cd9ab7090e59b9df67b377ce60bf6dd74e75a17099b365d2ac8c0e145a222499b47d41521c129cc02668db96bc88285cde706d3c576ba468077ed7626d82f07dec2a974d867e770084c2e2f8ce9d2e808420f6246c26d928980dcb0258fc9e1dc766dbba7118f9b442feb1e6318112c67f304a866e9cd49af4628e8fa8e425482a3800e5813e6f52cb99c690210dc3f939e87a27a4435650275a01008737a2ed6f66c6b104113279841af7c1da01fec21d636bc6059be2f48c172cc3878816d3598665ecb676012e40ff38831052d67cc4e3b545221a088ec5a687ebf24764de612de9eddca5f45f7039bf5d6acd461394d01857efc1b2810693cc683bfae8c2efa39f988d27136c772a12d090f8f549910f1031eea34f08f85b1d103b0e729407da828519b3df1cc83b30c0c9d3f38adfd149806e560c6a0d14a4e383a3a2afc43b3784aaabb740b24d244e677d89f26cd620ae0adbab1ac20ba1ab74f8d5cc605a01e8c2a2c4e9f89630c68d5f20289be81e9af08003c3762f77d264c83a723d3e9667af0c243b4c91fc91169d2342b34ad59527d206a00a160e730ea5a8d80d050839d46603edb372f8b6faf41138bd0b5fe810ed6035fee2c3f2d79e9ff651ca9ce965108a054db3ca37dd421f2bef5e28bd5231b69cde49ce42285fed0e720159f855c530f8d7f53b7ab6eb7fa6e401a213abb314401140012333684d849be390d177597fb4ad27b6c376a9cc1622751292a7fc4285dbd5c2050ea6f9c2be74fd47251c9a3dd27d84247d1b86cd387bc2dd318d7398365b97afe700b22569be91512d589b2e57184c924fe4da6dacc30740ad4ee4a6cf7942489243e0c1799f283fca2cbb957081eb55cf1551f8bc40084f609c727d61aa62ec617b7a38bf89c3f106c4ed8a1f8735559e28916dae6afe95a76f376cd1fefb2118797d74b9df73e495d07b34ab82104b58a4cda61c313e819fc7d8de0f89d29e5f966db38a66fb8c9eedfd6b6349aba4ae54b6b3256550767b47d085c973ab0ea6b69228fb3ef4c50f4ed13b37076575bdb3c2279ed62e4a7c0611f2af3c98126acc978cc884438239b30bf844a53190f91dda766df945cc28308266a8a8e676a72d848d99cd3b007f089fec023a366aa107523fc6bbcc3c55156a180d7ff4fc41e71e10061ef244fb70a572c7ffbe0829386b0e41af632541581cd385c4a276ac2064b4a3a9fbbf28928feea616a5b733f298b05c473df852cf94f6adb30996ea71c41123514f9f10cf2b925867cb29262a8d1277a3bdb1d82e2093c726fcaae8d0627c720461a5b19b91a5601fee5fe4654690a0d9316f849e7dd9fd8d237ea4a0b5a55bec8d838abe46b4449394fe6f53c110c6d31ad98293d8224728d6a23c50a7cb987662d1b5287312f0b7aedb098be763326a23375220dced5531d9708863fc1f9baa083e37b95249860f9a302f32b0116fc51702405673384e349e71ef3fc7f10b3bc8caee657037478067c91ac6fdba0bf663f40e694ab70881df3e236484f43e3f12aec1d2adedced550d948d078ce16994a1d627babebe91de7ebc487198ff0d92d860f40e6bfbd7a853dccacd2a98e9fc1419fd48b4e5e664de9339081da0f435186538e34c0fe3c4d9878b164e8ee9ffd232b4b91a1a2a37a5114a102273c033fdd43b95a079449070211c0ce0681be63280cc33c254b282f6f1fd3a8b8e0f0a6295263527204560293f1aa5cec8ce9487a468b4d6a0b7361975ea842c38ddf3da9f6e48d769876f39e4c0d38197cde9c692ecd04d888bfee9beb6e9ec55fc929e704d0a2e95e63a8b67baf2ac7ac74b4514fe3f5e8f4a0f1920fa423c640713f00e1fa6cca4cac030b842d32d0fff1c687396857e5a59f8e89add84eeeefce1abb60e90665f2d510e16066c178e3d2157756247d4bb59e2223c8b0f0f61dadc88df8a0e151a89668e2907c7e4fce11fb6d87aa9bd6c424f0667c5f871c806a97149097b1e058cd8a1be1ae136b61fd5c54b38e45dc593cda84a6f5444c147ef4c2a11c6d21f4db8f50174b9538659e7e5d4f116d214f5ebabe18728cdfb083377c598e729ef11bf1c24f624f95e410e702b45c6bdc892c0961602918e46c3f2fafca9f6ac088a95bd1c3c9905cc54a12e5f15cdcc25474f2bccad71c2560e43f50581f9700c24c223da2353595247514c6dba16202d736a45da9db385856107e448426d1a47517b2f3909a53aa4083ad7e00709dce2a61358d3f5490555fc95a085541bb89a1cc720ea82538753d63607cb92f00fbcf35fe7a3e2adc564d52c1a2251549e8ab49ace64cbe0a3de3268ea170f321734e6e845b7027c8b2a166428a39747f6b4f3598b3d80bbdee7737ad470e1292a4d84778715c0b486ce040ef4911d8762520e156f5dac498de023e7e3de59003975e91cb83def79d473988e3b8787b1029a301b2a193779969127cd29d5d405654a81981a860d347ece3183c7bfd3f06d4700df74cd9055b2a0d8a03e1c3131069c6dba0197097d8c0633a59b795e3d2345b29f0f16881007f5e8ee48d0022fb44ca5255dfa2ee5128daca2d08ce1a24c8e7642578a5fbdd9e9a7fbc5507ea46074024bc9d0fb65d294476d191c01103c58666b1a9325b1a08a50b9d9b6805602e6aa865051409f1fb25b431536e1814c176b289f61b5d5a6f1386a98790dcbc1fd037decd3f9fd9d4a903c6af5b4e556beb6fb72a184e273a4165a4bc803697705fc46ab90f5850624001fd25544748875f1a901a78e93c6fbd81b9f261d73ae2920bb92355cf0d64ceff3692fe39f744ead577513ee66e4548ed6085a66edc335c7f9999ee5731f5456068010179d90c2e7133658b98e90fde12edaceb3cf8c866a2873a243e3185377e33d5e6684251a6e45ded6ead88ee41cf40eeef0da27e397b1d7b2264903235ce98489add35bfa399db98f88a6fde48baa5824913689a526823cbe53434b8084fabd59eaa8aac3c843590da74d83d6cb4d51449fce287fed65739ed88930c3119fcfa5cb8fddadb4aacaa933ad7f596100e6bcf8f4c9bb4289c184e309b4492c0d24bbaa566fdb4f69f05e47a4444dc6d2a3be04b48f728a686b4ca71099e8c0f8f46ead08e65ee3e12d2f781fe778eb942c848f3b440fd922f60545df21e46197461bfd01538be2b3a55975dc042e3ed259a82bf004909d70aef573fde61c1103f25ecec2365becfb864673a3152c2c99ab7be25aa506a43437869509ef0dc856c8581222d9bf8f23b63e2713e1f7dc033330b87c60256dda0a0e69c7bc5b89b74fe01c55f81d2edb2b8ba213ae8a492a7f05e02eb8f691996769eacfc4978bf7a2bea3cd54552cc1d2e21ae34f1e9ef7186e759641ada7f4f109b7a71d47857d5a1c85e9e8ed13da852aa4224952bc2e76a963c5eb932dc6fdcce772bd41f209c989dcec45e6c08079ce968d1cd9410f522678747831732b2674810022b0ba81e73f1961d511748ef19f57ad9bec5575b37c6b6c18a55f30b86ae94e8884fbb3ef7711389ccf683f1e24052f548d6acbca5c6c66d21ddbb8463c303c76163c32995cfd81b598247c59af7bcd11eb69f99b7e946b5d607bd92c28b921d3a4d2b11c585192af03b77ec47e53db2d35a52b0cee06dae13f69e85ec0be676d96e26d2879d418c9b720d1dbb2b5652a4646bb0bb28ca0d63a67e275fb577cde1c6636451bed85494580b5ddfebac9a08baa377f2fa55d53ca025120cc194dd6c0227bb12744363097fe626e65e507f02683c4a9d924d5b82254528cc50f3b651d4dbf451187a1e33c192e9e5984132e7f1abf3a267cce8fa8408ba0affb672b5eb0df32c0f29b3e2da24fc75b44d08b4eba5489b7997de510d9935197a9fba1741b8605b87110cf7f70b4833a3f7ffa141385cc7ebc7b1b46c738ebbb90cd08fb00ddcaf41c41f653939e319a64502672e7678d1beb63e0a272f334ac795d0757acb508ee7f874e3426e99c376c22f423f15a41f89ae484a381c974c9413a06c2f8790bcbc3565587de98a21b66ef608eda263061c32ebbb742dc669aee26e26e726dd1b1f38756328226d784918dc8343fd1302ca32fcc438f82f99ae00a49e032a7364504ef2bc74a5b992c3a911cb24f8a111b71c39b2105b66cc658c558c0fddfc939b8174b4188c58f43a0161dbb9e6b2fa370dca7b81bebd16b0ec900bfa3f07d4de27b5cf1079352d0f4dd6a36e49232915f9e657da4ba4b4613555ce3baa39795db1d094576cdada47ea89b605bcd16ec251faa575a41699c4f0a6df7148d19c1ad705bfa5619bcdada374e48184042c13f7ca48ea368e0a39482f903ac7ad47bd0e21d366ba78834ef3e9e636b3d9a09aa863dca6c4235c58ed9f641b95da5734276227a22355b5096db786782ccae6e6b73bcbc48ab6e1fa808f4d2f59be26d801cf77626ac5f23c576b1f65f0c4ebd8f255686a225b175ceedf093b9090c8163e7afa21ec3511c2a3d91176d1abe9b6991bf78ae43e9febf8fa39372c74b5f8f69a835a852cb20f7d09bfe430ffd3a490ae5077ef5fae08346b09c5824f134dd7de09d42858d60149d1a396dc29faacc5245f9d6213bee65e623884d03e310d4ab5896f81907436b2c3b25b0e74ffb4e87b1362df34cfae0914bc8cf18b47ad199ee3a2d31ad31a29be2494bf74903785c4fb22be8e19046f1996a1225c0ec97fce8c1ddcd94d73ef5081ba8ac634d5129396723f50cfc8daeae2f5a634ab8580ec8cc1ed463d66b4ea67395f2424dc515d1c78596abbbeaff9c1b463a9458c65cc3752df57c92e5f6be102c7544cff22cf3bd8c63547c80ed541e4a5582584e2588f96e14b5f4a7fe114b136c9d947e0eed2e52927891e7192b6c1575076baf7714710d7ac7691735f944196931a3e7f4b1a3e4f2cbce23fee5b83b26b019da442c564cd6ca0a4695abe3984a7d2e1a6807a731e35873db12cef430fd5c195ecff6b536fbdacdb4662f5c8df692f8d52a9d2b4aa84a64f9f048a85a9cc37faacccdef7781693e506bbf1dab43af452215ac14675b5002d3aa30251066d65cda7b55352e96f10fb29f8bca7e68691ba87a265c81b02d366cf6c63468411df0a1ebdabc87ff2cecd43bcd75f49e010e93adf695ee91a16d220238f0dd3318d98b526ad150cf1878430ec23056fe3117460a91198e0e8a256ed7861b2609b97132e63425edd03714191de20ce30f998ff0b8c72ff8ee3dd2c2fb9cae59c27083484fc6e621ad09482b1ca8835adfa5b90d1b5d55cbcc056c00050f75c8cff2ed2857606950a899ec18dc7c3e9f6901c18ec250b3becfe075f9b97bf5a19d6051babc62ad45e6b39d85643ab0a7453ca2f901e67640043d022bf08f189047dc154e3cc2f57ef3e9e9c1c10e122d1b2ccef5b46d6f6cd2ce16a43fed0878f86617a72d82a30478978da1021c5cdee136ca2451fa3fea180390a0246a5be2e9d1d57e2da20e6b60134c68b14f63b5e2c3b8ddb56c780799bf88d8c53fb37f7f3bc05c8920af5a4419ef4d99e9a0c6b1996f4082a77b734bb5863d7b4f12e333aa5c54e05b53e5e71fa4f23132b63415a85ed5ae610c0cd5eb4116358ab72838ce51ac5b17b0e8bb8183fe5f8627623598775fd753a3b463b72ad73a66551f17687ded02fcddc61284e386138766931ff3ec8ed27438ddab472bbcd68988ae9eb76c6db5c4231a5a77a9773676bf24a3659270e93043e7d2292a8d215b2599c561ab222ab782cf8467d0448dc775076488853ad434b2643495420846a95e17dc19f9ec31d4c8c4834d2ffc31fffb39d5d4764663f76157f45e97b1ebfc6836c8aa961560f9742ae757ca58be751baca01a7cde8a415afb2588819bc6f03aed44543ceefb4b3eb4936628ce5e05ab2b90b2e1da2dbcddb8809259ba2f70f921e866bd4bc748d9267501442bb266d322ba1c7c3a00db80a735e2e2199ae758f4d3646e3637b2b787e035047813a2221f102b8e3e5ccd9268385b071ae08cbc78333f2d829cb8358a71dce6fdc72eb0ec102837c2c789012470fe7227a600012f6c8f17f14bdcd0e2f5ac482b13a19545547ff48722dd05c4b552eec4387ae41ccc9f442bdd59df67955f66ae2a64c2411d97f298af873789c098ff2e80ed3ab61aa67d6689cc104042a21fdeaadcea6726ac14d353d5fbd16231758e784a657b9df0fc36e62ec9f3650174370bb89d8c63f0502ce68fae6f80177f9d28c925c7af4a36365d1394e15c20703694ac9f02e0d0e24d0ecf859cfcf647c2331e28a11891d77999d0d78b3c7e422f1ed4cfe9ab2e1421015edac5cf9200b7a5cf3497fffd5e3716dc1b4efbc7a20e5ac3455e888f18252e46ddfb85af822e6636465725998b065dcf748f3615f1f87a8a92926e127f15aef6556597b78039fbeb96b562b93a805c093ece13b8bdb314bb47cbfbffbe351b005361878d99ca8c255e92c7706e93e78ba0eaef8100afd434e914dafc6f443aca0acb7407cfcfbe21ea8c6df7a7e5034159e69615f8c6a82117d79c9a3d7bf56d5e09e0ff9bd0ef955ac1898f07951d220c60a0e05ac93e5a82482f518d9ad441b20147e18f4e32aef34cbb9129bf51507996bc034ecc8f7d4222f0edd70be5f92fa1cff3a8177f77e983aaaed52a4cb7f5f603cccbb9b723608e4219f2c0fc6c815148ed93e7f984cbbe377a4f65c465490af305b3ff4edf441dac0b79aadd4e127056b92568061e5d5f80c05c6a22adecd13c02fb08c90c1bd637b9ecb0bf0f08781c16800b1bb1276308d3ce3cd10abfdef95b06bea818ff7f8cc174de51041a3b5b7eac9b2331589240a8ed2f7fa6ab751d05d7d0a9fb46348a021c70aa365b4f3e9cfaf2e74005a6ec5b6a7b7ffd6eb66df887da7399b4ed31f2d7146ec94143e05bfe97f40549ebbd4a1ef05aa1bb869f26bef18c6cb7fed31109d96f7d78435538af6283813b188372443248f3f7f771676e54a462ee44f890273560e3121a4c8ac26021d3d3cc37f37392386d6f518863a0613dcee4407acd3bdd869f24c7e06777013b163017a569245bbc360d8f1fff23f305696d2b787e8ef3da3721b6acff565897f3c701b3131a3d7d4ba2cde58618ab12e8982d2f49f9e0df484242076bf851679fd2bd4c5b3ad60f0de61184ccfe4905b0091e3584e57dea4455bdb08af18e0a0b25a67ed948aa06e9bef3d60a6d51288f7a89f3067bd9a868fa09c9187a63a9b82f3c37d046475bd193e6ed094cfeeb5cdedd070f7b3299fa0b811e9b9a52aa9c3ded7112e4ecc71058a072a7b2fea47b4fae1687599cf8109eb1dbac024a717c5201becc993bedee57e76032480b174b43dd992c6fce3d769a6ff0a05c1dce5bf163ca72fc2ffcf34c99367f8aa8ca8fd164c56f818814fd39a2ec3e4e2f4479b9094185fe710b45bc4d11da2a7fa81473c1c8957c93f687dc21707909e4bc2d999597b19dcb15e488dd528aeab8ab7185ce128872f6822c9a9cb68325b616d8fb8cac797479d022559b0cada1b8092b3e11f00e6a8ee29999c499d513cc70c718daac9cc064ac6d8825a61917213fe0805b87bacc2d498f913d44baf0704e3f0216f5dc9fce36f2d4a28046cb18e711541276e68beddc651d961a214deb6181c0d680c3ba9a6c3942247c6eda34c40dcbe51697fa0fd27ce15884e3fe3db85c62566b08492e375770061b95c3e4432c22d96313826656b8ae83757e70811ab493b59c5232916f605fe6e918d1e2c6d72ae98cd18218eaf3b7ac23d79e0021f6d1f8ae897e072db8731df3abe222c6519979f474e7db7863a5309469422a597cec0fd230e26781c086de8404458081583ad4c46d5d4545afeb0713d4e7fd23f485397d93786e4337eea73074c19c2ac2acf4ac52d28866888401219364784824a01856f7dffbb484a5fbd8d0c3ed7725975e056913e65432b96d0bf7a55737f933c514d4f74a23fec59476b16f16d78583a2e9efd7292ab01dd488204c817df792ff25fa14c58c2affe1d81feb40de4f43ad6fc21cddfa540a8f126e9d7b67296fcac813fbf11cbb95db231257a5eab4d070bd02e8faa72a83108c6d23aae04456499f259469e5d2663dbb359e1a1731fee992fcd7f5a9e1e51b65df69369ac0b9ad898c1f2ed7c0c9e74fcb88b55bace2ac4cecefcd6edfbf62a08363b036853f16091d93b54aa1d8b45dba6cc9180bc256ec821344caf8219d4b79eae8f11181fada662dce97088cbeaab269e60fac73f89474cae4516eec18e1acc799f7a024a0c99220504002c0dfe95d09459f10a84a27b853dfd95adfac8f770e7dfdeaf73bb90f58680313931f11670fb44dcfd33ab73b6233709cbdc06794f7632206999dc31b5631f8b07990485fd057e17db18ef93ad47d52eedac0cdbebd2c2e0b07f741d6959dd8f3471661a843b43c0f755746c63e48bda5f7d507928e5f727ec63dc41e0a6f43780e27a04ae6f1cef9735fd65e649ef341fe8c16c18a54c6f790f0a48022090863aa774a87afd886d9ea30bd64934a653db666d764e6e990cd3b27da523b651c371189aed3434443f15bb00799893e32af5b9f3d8d297deb6982859078445a73884841f8a69a57b0c5af1d0ac605008425469cc1c6b99e93bcacc56bb6a68802a40d47945e974f4257a7ad9f8f0523dec608042a9de84612d0b88f4bfb312652ddcecfe697852e388c0f5770d0b8f92b2f5a0842c3fb6765548e0fd586d97d4109393b050dd17beb418e0cc9776df55c96280686deebdfc1956e13ae43a7e54d7104668aaad0da49d97bd9b4f1379704e7447e24049cd9f1c6614196e4354a240aced4f861d413a81b6b5f1a3f5bbd096c2678db9746b08fb893342326cb234e4c3b46c8bbd6b768a791b864a48a5e1bc110bcca2e4efc641fa489dd6c5428128beda3aa86918694ac25d3b6dfac7e49b775656a9ad3cc1b931d00f1dbb3c0a4f3fb36a4b206317835207e5ae82b2bcc850294710ea28bf1ef0109823b256c34a6a41bae4297e55f8e94ea5c0b0a9ca54880e6862d16db0bac5f00959f4907bd54bfa024f0329cd206a3459a982fa6c2a01502e8a90dad464522f50c0fd5df13db815bb94e0d2b87e3d9b473c20d605a7b8f42bf44979330b8b4c8c63bd8ccd5c62f804a79d1890770489f454c7e71b03cdad23740328f93499f7f33def6c4acb411a77f4c5faf085485aa83cb0acb296e1bac4c6fbb6c36b9e7fe366c16f8310146216cb33923b17adec0f042a5b6eb96c5ca0b81d8ef3709ae9a5f9addeb713c4adb555529747b210beff5b4029da9ada758968c1373040f12741b82874f5fad30e7a360de5e9fe3bff6c11304deffb47048d6ad52e5b707ed639c5056deda615ddb34e84dc9fef960a5e5c84ccb086c88b4afe25f0643ead9c6b66bf1a018cde88be4b8e25c9aa942681fdbf21aa420259bc4ac0ef091a32b7593fc5f6e84f2a3f49880aee9516a6bdfdffac6f1fd01dbebd239f7f83006d79f1d96103a00c629f13a87a08104292d2b16c79668b578b1664f8242cf17f1726b6f35873bb229c22051aff149407850aca81c5b9100c5fc4b3e3aec58f0b03fd189daef359272a1a03cb948282ed0724a2d1e643dbc8870c00ae9ae9f03944bfca510303d5867c2fa7e28b47cd758d5a16b54d5646e2c8e8fe3c26f3d58f9291e61b746400386778705e58fb40dbb18f8a263c8cec5268d4b2289e7b61a795c0f0f651f5ca06161c0c0b5edfe0b951db27bc581361e082c4e760406493e0c2b58341573fe9213e7a5048b24d3a5d29da7e103841fefe504f98a7b4a47dd81703a4c3ce20da137ebeaf7c14a22a8535ca3c5e79bed5ddbb22c8b90e1069a46373cbdd34ae2691720be42890e3812493bc452f9dff57bf50dbb8eb3e94093ac77c0f6fe21eb908cec15dc7933b3fc26c2b2f9b34e8146e36ca046c35a1ee1987dfb0d04a6be500fa5be88a56a3aab59b354d9f37e0a6a6a3c847e04ebfd85ce462ab80e19aa832b1e70450efbce49893802d29502c20428d85b6db7fc2cbe8d0a9e2177eef94925d3ee69dd0f0fbbe00ba5ed8434d090f882f0ddde167a059e95a03ac123e3f00ef5e41e9961d6248eb8604bc80541503ab5c5395b70b42cdd032df33ed9bdfa11d994ab128995bb128676b7f095ec22f8a3e4a257ad7785e39868b6c9229310fe2af6482f172e623efeae0a152e684edfbe7603cb32c36987e109df6336080863ed85b27a7c1fac1c1ad1b9f0fba7f38bbbcb7b39b91e9b3a9271cc7fa0206b9df2b8970c8b7e15f602db787c087e983c55edcb3784e6ab558d57ce5ebd705b2ff78d939d5ef63578c22da211dacaafc1fb4de63e932369dac1de019c1a4be7e04e6300f311cabec21c01a77b8e16df8daae1e1807c09ead060f37e1443494e17122346a0561d88139c717e658b43912085fc442bea602196881dcfa5d5fdaf6bf76494183f4ce868bc80fc6815d7569ef59867d02dfad991c72b7d71f71a8acaad7f4cf1ddf17ab881aff302bf91e2b3da6c8edb85e72909a4015fe578c231c556df501dbcd9885b156224c676caf842021d7fa3882e4c0275c494adfcd7dfe39b31f328c7b672959c7f7fd9fff6b59af28d4c57505314bd0d3568bf92ecef04d1da0d945414fa8c3e9d99c149ce67b56a30249d9cffba81970ee300a63ec02f16ecf6f5b669f7d0ac1079797016c280b225f3011b257a71e311c76a64a99327f85bd971273eeb1f4e3a5914ca06ebff0ac4520113d1fa8568a39acd2ce8bb9b573c44e8d8395d653deeae1147dffd22c4aa222f013baa9bcee3a1a69b08e053ac338ceb44058da9e1bdf2f2594de0f78b378fc7c467a483b3","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
