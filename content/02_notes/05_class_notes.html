<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"6d49244cc36ceb2831d180fae2d9dc03a4f3049c96d90e6b1749cb7dd1b291e61e8cccd1085910aa27f4712add9168bf3030a9c65b908159068e8219dad77df726ecbac4bba1ce6ff2f07c65a9eae8204f08853798ab472d7dc6d6fec8b6a66d00b1c4a042278cf8df2b30d2cabeaff0624c832351e9f6d3faa98b1fc65abbe0ace3123eae618647125c51009b46d08af463a852d2355b4fb309eda1d43cb9945bd8ac89c266b1cf7e94e623d069caf9597770c9e313ec21cf75c97e991735b9fd230b6a6ddcd6b0fa812a4284735834ea97da34b9738f83b12c0221a75586834a346a422672da1a01473cb996fce41ff6408dab2f2e52ff983a5ddd237604bb030f0d05b537a1ffdd61843e28097191edf43afaa0c0711fc02ef166f20d86b15886dea6b98cb1336a19f0cf547bb749ab021c6d74f7fb243296fc1bc2b2cf089b78b59db6de9014d4dd221d75126c9b4d7cd60876563376828baf9aacdc3a994efe35285a844d3c1f5be7734d8d3cc505a50bb4df9e6d2076a5f70bd8f1efce0897648426ff75066c97ef65246005a7d5020a0d44d2c755e34f9608efc8e743786ce86de737435a5864f3c73a00454ce1b7cc0f3a4ecdb518ac52df1c1259b47ee9c2eb10012eb980e07c04c550d075e8ea10ed82045611576c1dd91b0f6ef40ad790531a9f0405740b115f4256526e59f5f04165cdeac940bd8174eaf7b8528b509fb47d78434732b9eefc014015f35103cba1779c1e68cac632104c8983e9cfb2efe1a56bc94b22a1695f7f29b0c68e5159655f1f7b922f7b00ca55b8aaada0799effc99baa6bbc16c3284ed63e3cc57a7111062078963686ec8234b74ac3a5f0c824a4267e602d37f3fbed33a0f182665221c944df60a826832c270f71cb9edfddd4b327b36c380eef0d54da1722ed5ea098f78afc70c71e91268e4968481998d2769977df9b510f5c4add7724f686a794764ec644859a4f829e2d57f425efe4ee1f3d449dc9d7bf9ec66b60da0355545b06feed6a1710ad2c938f06db1bbc625b03018a24fd2122a705cb5006741d72b355256bfc801c66db0d14ae0d9ef1a24dca21400470f3ef730d8c392f054a3f381a086e11eec5874967c60833a5bc5e27d1a726dd860a976ff540910cc8434b5991c0d048b6445b2f9f46c8e6c6c280237ab8a2ed3f7893f6ab58881e4083c20054f6784fe3633920824912a1a5aa96dc20818950eeb545a9619428dce1f2979661a88891035317b4819c14c5902c432072bec836d0b44507e5bc6b17888e376736bbb3d04dff1afc26881312c57eebe59816610b98f5015a77f4474970407adf27fcaf8821122533dc7d523b657420b8802df1761c4981d92e4090a06ef5c241d0ba29a7eb0e679019dfc3d899d56f16e635aa56e45cee4f6b6d958304e6e3e23162838c7bb8407e6c4fe203431a68d3123c71e7bb3b2f0b61193098bb3a2b853f0d3ae17e8a74f938343a3c05910928bf874d68ca45ed1489c02c7c06f225ce1371b12ea3fb978923cdbd43c5358876af9a2aa4d96aaae3beb669f15d024bd9902461bdd926d9be0ccbe037bcb21128cb53caaef258d727bb7727013a4c6df48a1d3fe6677a8a7ddc1d3266fb235c7139fb9ffe833ec2fb617db152305bdee2f825763b14190f7510578d94f163941477d28befae57d7d4ec8748f5c84b7602f6dc3b9be585096adca98f90da4aae3465c071c4aef1bf78db8bcfa3c52c9fb5f53f26acf178da5753b4a0e54a1d1a093ce577971435e523fc460f52b4ea2e564e087b1094c48a8a17de612af20808831ac4a9c7ab1873460266a1d0a99ff58661b2b31e89d583bab074763b0c1e1778b2cff39741a03c483ee111269ea07c06ac483adf37c68fce9df3818ef34375e13a10c892f8d7e140a2afbdcb749983bf3189d59611644ae5f3f95a5cac5133aace283ba20df291ab8eaa52a57127bfd3fd60e255265ecb385329f410f5dccf1e252cf9c23816f2ef136bb71cf189a4c7028e0235cde7fbb917a83f0934c0700c1d0e6e6c234fb2240a3aac7382e17f4339248c1e4b33ec25e9d8f44792662a3208a710713ce1af02d38a1993296a742b74997bbedc78d0285aa352b5bbb12a2ba1bbc23dcb15573ad53cf8c21ff0be889b3a7168d076db04517969c3b375bdead7c38369784f3b7c8e2e4c47462955b1b76b68285e34f6b51b84bc4c1eda0657050be087d30df1ccbdfea227bc4779acc5c4c4a25261afdbf60668acec720dafd337f0a6bb1e7aee44bbd7e5dde69bad7726a57e41589d50283f59871594bd86205ba9f635c7fc24ad833c67f5154fee6198cad5974c0677952b06b13dcd1303ec98446b51224a108d57d6d27919388fbccd79b739f7dab81ae18a04adf4aeac909b0b190a59308ea786e8f46ac9c038fcd64178e81dd7320fd0e7c10acb3f074d4377d18934df5bd3889a11df12eb0d7db7e6e84318254f7adfc3a57b31e38a8c22857f286f1ef7fa2857c0ad70a771dadb9b5876a26fca3e150533b2ab532bd76e5799310ccceee7530af529870eda96ca28605fe8c2d798d55bb1feb3f0222a314507c30985387a10f7863ae910bb445a704b59a07704817c5e55eb6bfc6df2ef0b2e6db088cc2238e4c9152ee811bc4371ffc7ef891b6b7c94c3ee654493fb69b66307d287de6f352d7f86fd8f6ba392c2e73ba3c6a2f37a204915384254ad8cc67a339e05e7c95f7083f9d85fc69b7966a8adf9e214390230079b9a2d1662440cb14f1c57d6a7af008c08da68accb334073c278229a74966fe93f307107808d19692fd8f943725df89a14e7324611bfb47b35145454895550eb38f31af2dc1e92c9629307787710712f4a59a47abece1867f007ae050134f02baca50def6dcc70e4c81a172d543d04f6c1b459d65d9346d9aafd7d6039240ada3f462724224820e67671c5d0610c898e35ad0eb14a90c10a02e64f9bd405ff5fa98d46387e498475c71cc8c3056c64c941889b5d50f34dede72d54a6d74152235563bb717eef5d47d369bc4ffd69ada6acfcbae59398b8cc40c52e9b054fb1bd481703a411c5f67cdab2f0d2b9c46f82cb0ca76812d7eb7e248fd6c6e258565e7448058f7edcbcea4e442f066507ef4b90b44e1b5df1db610235d402f2cbc7d9b63e61c9ca5f4cb7b825f49a3c44cf127978024d8765ec7a5eafb910b6f1812b0f89659dad86320ab6a4faa256a2ba65472c9c1a864967dffd35dbcf6a4be38d3a8c65264d37e0ab27d1ea4d3bfa3c34f4c8a5fa9ed637faf2f3bcd9449e732c5db8f591e7673faacb7778e12d720ed90dfa04a573cf2c428cbae1c60ae83f10c9ab2531a3bf2d45df786a25a5a750b8015033ddf1f79b3050df5f95e26e236ede1ecdd23577800b4348cc26f306bdd336873583bfe16e990c321ec71cbeb6d7f55b4357b529a499f3f17e9504b7ecc9cdb3ff459b6f76bcad8f39d59eb149eefb3a8d12188d6fde8e8433b620a089cfcfda5a7e8b8db83adefaf0fd20e4a80b46454825a25c1379e55676ef2f190794ec9c8d3b5075d6a7cba9a03ae5230452523dfd669f3e2a4a92f18c24d93f605aace0c380d0f032f29d753ea54eade0461390ca71544b8be0854a6529826d47fb51991ad203ce3e02ecc53b42a4259e9c7a252c5f12afc27a93116ce79be32f8d77a786d393cd87650476ac8bd8108d96d825d0844043a69fb2a678f965cb0c996ca627de244577c135ca3b53350827a72a42eea2da2e2f427a9dece4266b654d09ae490b6f474d504a0e3a74f373a938c0c3b83f0a09523a2343ee32d3ae0a803872d1540be75041f4d1b3180be041a04f15708c8ca5540a9d0178c6af337fa585b9098b22cf842fd92e694cc650cdb8f66b362647d2d955bd3b3b98a51ca6777fae16c5fe349ada483cce0df5e384268e0327005648d63db4d148efb93b7e5e234a80745eb8bcc15131709ab47c6c4013cfcd1bca40bec8f8043f007e1c09b57f3f3c353ff99cdd878594599c2a1e668378978b869e49036e5fdc37fa773bdc4f3a1858f28ebb079378cddb86557caa2bdd618f679a22aa2b5d3ac138f132a8a7e750a0540d4a154691a6b4908fdab60009afb46a715081ebeeafeaaf9c7581d0f76ad89b6f41d07c78caf1130705e66b2184db6db5d97ee3fab504b18e66137ab1ee0b6c4891ad901def1a6dcd0263079550000e55f8c3d7600c57139041d79e6c0aeba70ef0e6bfb2e725e0da8ca74ded97c9ffd8b29549165c18078ad901928043ce29f0e6cba067ca7e88c9286f6945359ffb9cd11f7a2e7628c8ee93a49a25cf284eb4c8f7e32e385c000ed1f0487139498f1efc9d6a78289767131aef7076d3c78574cd0ec586d44c26ac35609372e442009f0c389b81323c8adf5c5fdc9a6c36800f3b7d1c66d3ba70be53baebcc10195980d9979efbc4e58b616656dd07dab519b5878269ee4b57be8053c4f8244a5a28a82487678e8026fd9df1d5e45e98b358cb820d54d26cd09c80460344687ac8b2672ea3e4fdc422e63b1f85924fea99382b02945f296edcc82f908441e77e26ad17b14b7b132cdb5356b2f37cd2af985fea6f2925b06d595074864f5b61581887b590b054c1f869b05133fd5af448fba0eb8077913f75f2df286396eeaa54e8e43b6e6a47b4e545f5e290abeb19e4cfae6a8d49cd10588d8ae423b87edf02d9e773d6846b395bbec8a33b3b957cabbfede9d689ee5e923a345856f7cbafa7f717d807be44238638b24ecc16450ca648b80552a6c1417a61114549b2648ed6fa497674bde4101ba0dcdc5c1abb046e0700fd5d976af21c855a5fa3a02c4f6de9de80aaaf00a38e12e693601e729ed4e81f6ae69022219f6d246a0b451a6fa0b9cf0a89a2122636645c1aabad1364b35ed58d41cd93f2d42387a34bedd7a1ba95687754ff99b327f4fa564c78fcf5d2e8e6e7c0b268baf2d934275e9303514c8615113d47e9373f1eae60f39c87021dc842d5a6f0571d966d8032a608c7060b0a4dfa8c9ad10d85206296e4186f54cc2894981d3c7486a6b7ff017031bc237b964431e919ed14139b39dc0ab78b836273551551b33281c8679755a9db0a7a8f118a06da5dd3ebc441ce61cc38c119fa2369a6c3a6834e73205a0cc1bd40da50cac08c6cf82bce19b60bc08171b05eff6c5740e7b2b6268fc152117bd00524e5fe5d149cb6334cc92a38aa1cca1a44492de6b7098104bf19c0f34fe21c031fe88e855fae67abb889dfa8a1d01c4dfb221c0cf8e937a72855ea4dd70b828521a74980cd07ccc0439415083051b0eec86dd4dfdf52161e7846fc6830c835131f702cd00b995d2693bc2338cf57e66f0b92017f3b9a1b40a80488161f8d69860e6ba3a7692cb72130f714ef585d5433b5ebd4cc5597f51f53e7d3729c4c70e565f99bc45cd0c4e44d6e46dc4275c7f3be834194f078a28e80c8cedda7ab12665be891459841c01556b12092d6664c093792a29a2c671ceb0d4388def7d24b9168580e57118e28f7edc8fb2f9cb6f942e9cd6c6d926471c0dfc6d0ae4154d780e4d420dca697e26d064fe30659d151922c98a049d0ca14813c39525e464517088ad5b7e01ca9a5a2b6d5ecb3094df405d11732a2e9116ffa35aed1ca081764df93daba9a5cf8f9d5b4fb04aea1a7f96fbd8d60881844c42b8f59da74be3b764a6e0e9370ab925ffdf208f20d5155fd57ff09d9acb179e126ab7b94b7c3b50a50605efe47508fcb15f332b9d503f810e31f69ee2333ff7613cf08b27a6888e37b44d4ab07f232f605d59ddfd575d36aad1cef947d1c5297ee3cbec9101bda34fb7755369b2e5992e1e481e00f2c1663f86c5e0ceb10fd4211cde9557e7032eb567a6042c006e4ad150999cee8ec6c92c1795dae5fc20bede4697e37a375cfb24509e9710ed8f18741468fdf36fa58b0ef5ea868bb807a7f90a33e6f0b3a0e3b6f40150492ae6c3876c3d82ebf5c41c04fd7787666a9237af10c3c08ebb3ae5b2e24cd30229dff17c027ac6183f042bd228dfe289e065812e98736f4b4b14d9c6f49de1937b78b0c32a300d9382eae7650f00e6471f69dee778e32b31e1ed09c1fe167cdd9845842f573092cbb761bc655cd64d7ca7ddf59740fd580052f77ac650ff7ceb2dabd79288bd8e99a444b776f31b6476e9b279473e6d82eb92faf513df10ff1e0997fe864c18eb72d24314cddd63abcf8629ce2b4ef8344064eadb716e9d73bbecf6610cb5590574e4bcf302c724a15541414bd778048c65d5dac66e54b88c0e1ab8d782b64416de79bc9b8f007064e2652c0769beaf99fa134d0d9b2ab70477e20c244c4db8833880cf09259d96d3807d31e75720ad058988c7529652512b059d48dac5cb634c83828a5f857dc81ab7e777f95236c29de23621861418bae347ef47600b32aed3c7e85f5a8d664e111373b4ff8b2abe8d8f38415da2ca1d6fd3aca867fb7e56c47cbb61e247288fa49dac84eac76dc9be60ca752b713b7306c3bbcd688cdf35659297c1a464781352d9c939d8311b92ed7d003d0d9c032b124d9b01e3a24322e3f43d18e530b89e95aeaed159a0ee93ae9b0d0f8bb84b3541d6451cc4f550a903e901bce07f61746d87cf213766b2453facc7821b572789fc7e5518ee2b67bf45343d0f3be2e08355133170cbbd7150081765ef3600e897dcacacfba21e3a17684f82af830be21bddee30176cf06ef60755be24d6c4732b7eee53c0f6db030cd0d038f66e92ed853016f47f132be0119628ee35bafc8929ed87ed2e64c072fa0293ea0aa20bbbe3afc33d7b30138674e378eaef6f6ff9400c5e955884e59f487fbff24cb31091020a1642eeeaee2ac02a885848cab460b527c1d52a3d456f9d0a87dcd5472c8dc80fe808becb60f4a5f0687815c03e782c34b7990157bca44af63b8fb88a0e20ac297454be0d67286a0e5a6534866d584dbcdc31f3b5a6d181855c3c66c0e23edef0fe14bda859968a0729a495b98dfbf15c42c5085a36506bb166c312da40d447833db2da4401c73250cae756626305c46d2907849c8cf355384b486f7596b91675fa65491d129cb1b271ecbd11b28d782f5d25322fa9c2e8b7fd2d87e423320356cdabdf282cb328c1213c4d5d30a2c6987cbf58cdb92aa33e92c7c4bfb96fe1727bb7944c403412cd29529754b97228ba5d64f11bcab24358351d8e8e0991c6b1311e34679010345274a960a23deec8b302b3aff30a75a582a0af9fd3436186a407581f30bec11a09ca24f023e0a53113219356e109ab8b71bd8c61ebbd3cbf71ce9bf8b25a5029eb5c52ee9f729ae43c603031fdb1762058407f7ce8aa5d8bc8e2cb2f7142dbe1144482566ca80fd69993668d697f9640ebaf62fea5ee1b45a87c93f372dab0108a86af7429cc9290bdaaf6e845a1cbb82c83c396a3ef79d3804cab0fdc421684d6ab54735344e1c80ba8af6ba5723b7627ed4eabf1cced9bdba57da5d5576ec91cd3b3805175f89ae3ee48d7162c3114ea074f229bfc3d46034cf114e7585c64668ce495ea8b3c7281d13fbe6613469d399e9443580b7f5f6b956cc5b2c38b11a73a8be9342c68eec74223373424e09d813b1ba03b1f0aa60cee30a01114ebafe95d05959bdf99983efe90557da466d212734902d768b19ddadec835a37e8af639fabaeaf4324b929d72ee6c292c3fb68b67a6d5ea6621c726d1edb5735c114c2699f1adbbb745f3aab5adc8bf46db7af4683231f2e7da1520d6c41b360efc9b2bb61c011632d6b5a74258568779e5e73c7cd57dcac4e2330153f3b08f225b575b6c0455682b040f4b75754b3bf541100d30ff488dfa028beaaeb46b98aefd3209c82296df8692610fb18a46fb893d2b3a17bcb590530bd4b15acf59d447c93c52208256eb09fcc22e9d88f55d292cf440ee60da744e8eef37bb4b648ea7e84cda60eaeae2c180dde8a134e45fe73dca7419a771d8c375df9d8e20f88d1c54cec4edbfedbacdf6764f335c29f192ba23d8540b090569162cade6afd48303b01fdb56ed0362c639e76b699ddde3e3622af99bd7a034525678f86353629ab8886af95670f1a731e3e41abd39b363044edd8f73631078e93f1a86bdb94a69e69945f5b32e9871f28f0aa98f7771ac38888f9f68c60c09bbd9ef545d03d16c59bf1a2fd394965ebaeed3d4f5fcfb7216b04a4562cd1a71ccd74c08ce0134fbe2180e7c59e538148d74702dc2be96f413746d82865e2b32124512e73cee7605a2864cd76dbf958a704b0940243815a964e8589a8edcf640c813658d5d022a2848e4bc260b7ddd0027cd81a6b16eaff2cc24a17972709f9379795a274338079aae6647a06fc45528945882037020be768cd5680fda7480760c88914488ee27865c47438fec1fecd43846c7c7b72049a6f9ce4547ee3a0af2b41ee3f17ca2b5c17fffa1c657fc1728a08bc91cc0e45f9aaf0d990c0b51d289220329c55ab5076f971db8259465dfa9c4ab1abd734aa8f2e2a3ea6eb2c1914cbd2a5229dd5cd3b7684b8e40d0a44f2842b0b40d7c57d23749ff5d850fe07a0161d6f977f6aa4df5ac9e542ea3ffef05b56cc9f44c004f546821dcb1c1a23f86ce96bd07ba76d38af44276f3df55e9cc61252e0e42a22057e6c084a90733f7c8eae2e40ca16225a734ec6b7b15dd9b40677ba80f1deb8822a6540df38d509771227f6c9492fddccf2d0881735e44fc403cb16e0a3b889591d23866d67f8dd6206e3362a8fca23e4f635636864989faece29d7593fd9ea2ed6d411745577a16b36c83a85d16cb30b3721d240d1b8bf72166110dc7366071fed0c59a2f375d8e1d99947fa44ac6e38ce642e3295faece6dab81410dc0202a052f77811d0a6d2ea6467b58c339d396446c96168335442098071d1105a12617e6003fab5d7802b98cae4740547ec16abf184dae86790d85b5ef996f3139082b63b8409ed9093d9c1eaec42cb9ab3f41ef5ce4345d9db942ab57e5f7f757cd0f7caa5d9fb34bb340c8b9aa807c0b4ae073ac308e442c720e143323e175c669465135f1e33d4be928fdaece0fc67702e9cf48477f64207e0d1fde32a20b7c82a928905e60812e933e0a76e9844bb1033e039e1734827236c2748c3ad8a421cdc2b92bc097aaff19f439ea086dac452ea3b033a2320380c56cb63a031d5001dd0aa4176af9a1b27b3fe984e6263d671d324df441c9b2085a7fb00d163b6a09c55a0d0cc02d29e8856253fa948c71b08c1a52e23a58260312d9a84c9e6abdc7146b206fd94b4d0234ead084c7310faa7d9370015011b8eb735e2287c8dd2dae6b06123a81fcdf0cb77bcf4403d9c944d6f0b27283102fc65b2859d6183b18f12efa605a11a13110248b6e9c0fd3d6576ab5cc2f768497d839b2ee08fdb456466356b0046678815126a46ee1d05a9cd5148a88e00f8e8036656feb4d246ab0d131d68ffdd8d6a2372446b8a671947ea8b2aab0f459d3011133e897fc70f4902a41be048e40586b9388f094f57fe9a2e8e77d797ff0d938c9699fdc143bad35b24255ee9bd745188fa9a832557e2df3d068c2608bb9732f921b59f57291976693d377aa7bdccf6fed0bd277c2e40de7d992a5b3dc428b21314e12f21248b92bd8d61c7a81b0f9976f1764893a949cbda766c47a606ad5bc9f9d2d240984100047ed7e9105b63433aa6e9c0ee27c309dd24f86ddb14da0e1f6e2ae80623513e1519134cbbb2894aeac0d568a5e4d9764faa5be4e830e7b1b1dabd1f537e9093689af3ce70d87aa2971de53abc126839b8e7d595e1e5563a1e6658109f4dbaa59ded0001803893fa7092bacedcc874fbe835da516ce5cfc8c55d859b3c8d4fff461b33c2a820122ac08bd78fa75dd5928bde7074d9004e4f4a09549e4a92f28b0ded6f21543b5c33f62c67fec1fefc0cf32ccde170806a1feb0f44e3b4d3e22c11b05d931d0f5d4a0bacf98a9fa654a6d614e169895cc45c692fd0bdd90e4116af8e25687c369c6073f4f6d322d680df461718655d90d6eb9c76740593dff107fdaaff3008260e99e55baf947100c1e896d44996372dd16e2cb9e04d7f1ffebc10a1fc21f9a4c73469f1e4df595f7e5ff9aff7217c7a5e27e8b3341fd612e5eb9561eaa524c1d457dc42c2525efb55cc4bbfd14665d94d506a94deaa11ad3c9d830f6358813939f914470e0a60f1c16e71e2506923fbc756495e479c1d5dde364808272bf5d041dc25499c2961750307e558d8bc6a16e982b4943d05e183a696514bef15a1ebbe7e3623ecd067854cadce16e297e667a9640f8f7b5e9eb96483eb7043adc2d292d3be966a30bcb0eadaff784a92a99042a2144249bb0b995440140882e8c32b33d8ab61a63e06a9e5254d72657d4a9fcf5e45c011217a6ce7090f34dd642d08c2ef499ab2490625b90501d586188e38c23e95392a42f39f351982e587ad2da453f5adde353c216527901ce67c84997ad92eef1fb4a7dbe708a4b35eff0da2c6f7ffe3cfcb84b9c7c07f0685066bb45e966e53e6ad1d51c7e708e7236405606852185031537e5a2756901065a9f84dd71c78b0ea1d0a6a881d9fc09d6bd851301ce79ba8e5d33e37cd21c11265c96a044dd03717da62dd950c104282f03f8108a378fed778e9e79a4e3e6701233758afd3af01c402e912ec81191819a78765351e8a154eb4b02e5c1f0c35c37c7740276fdadb45ad2261e5c8c84a414d87f7a9e03108e05f1c4f0961a03467db62865571cfdbcc95b666e7e120fd767018ec0fbaed7da595fb46fc95f2efe57578f1ddf61439fb03d13a152431cc0bc7ca1c3f32f7136f27db0b84c469556e562a1b2a32d8fea3705cd5a1b93213b579eb62a69c047d4429b68476ed62cb98c354de2dd3021a3ff90f27a06ff6bac09a9ff8b70d91269d42cb16318bc6ba9b246fdb277d18571a25bd65e9e74c2e604f78d681600f69da6dedf3261e050bd2128077d4d085bccc3cd19d2f090c3b45617d5010e8c22a927838755eac39f61c3beec326ba9cbb1b587ff5a0659e042dd81b2a43f61c42e31557a2998c761d794d225f4576ce2bdcad37c3f434939417157e00cc4099690f44486f33c0f56a1b10378c73436ff9e74408dcc77d2343466a2a71218303a67e36cb0e58ab0ae5c2da1a9a181d05d31f34b686e7a36dd04f1cdb3a0041cf29b97e2b4050d720e6252b1d7a57dc72b20a067512c5ffb2283ca93dbbe0071361b95e5198599e1905bdf793d5533b750727f7c836150a8be1cf1d2fd4197eed984e84214c204127af71b1076ce8b8b0b43989cba727e1773b17b242de3c2355339253b6d2ce242c1d997bbabd8aff307a016b919e8917d2b8e9391bb176206b7263181e3984f873c4c401ee08f82d782db64b5f09fd06f4efe5c2b014b95f4c88d596cd4102c071942d068e20a521bf9b0349c9b3e7b646f98824e8dd79d414ceb6f58ffea4ea5f957f35481f37b0a93a6ad0930e0283ae3d895957900a443b83aeaf4d8b1048053b3356525ae157f4bdfbbe66fb4ebceaace6cdc63058923be9454c28c772f1baccb2d2e0de2f4ce5cbcd30addbd47e62e34fb0d7688d52ae7cb6cdc564ae2e8665d3f670168f49ce10105b6faf27bc36b9768d5268eda760fa56ab94f771a4e33948cb3ce74e68a7d94532b397ee9ecc05334a31f6d8a79747074f1a652f2d79591c0f8f59893045d2f930adf4f59f0c7e14a254c89731bbbc8dbe0c3ed16ba0d250fb79ebc1738bd3f8159ff8011a8bfd3ce1459b95b1442fb0e6caa25aa5e130f7280517c67a20aff329139bcfa757b7e2f1f6a640f927f89740bb586310dde43adb0df4c7093a3a70fdc93bb3ac5fc3c3df42f81e95a64f2dfd10d55ee81d064ca0de971f0a4665fb42b541c109a4867f99e061e201a7d4823368077838fffaadb76b1c206b3788963c425a9914e2709371fa035a03bd58e393dddf6b5e9094d02eb0c0b62c00c0df4a061316900d316f459848e2e58acc1db5abb77aec6af6f71b894e74de733b0ab5807b6ae2fb2eedc7b04200e4024cc60162d6875fa9c98561402510750496561cc023742875e28bfb0e946db28a925bd028db3a1bb3fa9c2017462bf7e7f1c9594fa71d330678aa94aa48d96bdad5219f61d5ec81c4887ff662ff6b055024b435244abbb2c5e0ec385c6b3e8916312658b29cf82293e6bc47a55258f0fc5b301b66d9cedae31618e1c07bb5766dd732e250b49de1420db9d52cd36a484628e435b09df48373b2e1497d5006ad26546f2c605132cb858fa08b76ccbc7ef11882f9aad2513673821d2b27cc457a271e9134e44730fb711868471aa6e0616f727f011c00621d3aa16734f30d7a3199e43d990ae18aa8492ef01bf962e1310f0a5927f060157d23b3e54c0e03a6bed20a98a7e3b5555fb13f02a38de8b39f725c812ba241a28dd387877cce81ad2f3ba9e5a61cf0cfaacf3aba4902bfa6b73add36b8149e46aa26bc966373f258d4bf730f7f09a17e80fb99a2c383a701d445d155b2a48a64292fe6af0a4fec09ebce0a161c494d65ab5bcd92b04f527150eb307c464bf95e92b459dc8ad7efd59ab67817e4f7ee7da4fc654c74cdb7c3b98af4f927f803959a9ad3d48f2138c1f9d21a02efe4b8c3c1de9dc540f50ab65e6bfb0dfae448d27fa815ddb5373bc9c0773ee9bfb40639a3f0929c285a889e242a33eef6a0a9d60773ecdc08630ed7c8f069319b3c4b677acf791a834a953e9c72542eee09197306d9d5721b9d2afff90c4a3731d5001498d628894c9b664d0254a066ae89f45fe11daff29e8058cb37b08f1e90b7f920635c4441541fd964cde8a2f737774a1a3757857776c2afbda91e49633cee1f8bd6ce042188fde3a2096637ae106537cf1d6c6b03a630083e4bdf746cd6b6529bde1ed238f55736c086206fd1bfdebafba932083ec5852a02f86b4c5240674466a69389c41ca22209a1f5d2de9ee956ab550d8cd4d989fe59b5857cb058c6301cd72658f956211badce64c858313b6b8ba8dfcc7c5ba1c9598070cf5f38a2ff35687fbb1dfef3395255d0681080645f4a327c0d34e1151f9d8628422a00d6a05ed8b5e34d5a0ca69e1e98cf818e324dc06bd3918c51fd0c45f04c384278e783629bab401a59b851c4b296dbf421c8a616923698f3b2b80d16e9d4f1788809e5bd86d3d1cd838fbb3b52d47f476bd966574630608803ebf27ee46525af958299dfa51b5f8746011688122bf59d60c3d57ea49a08a1629c566e80a5736e3e5230ed0249ae72bad9d91df09c278650de655fd2d3af569f32766bc652ed3ded23ecec7487155c4d8ce79838da983f195f3adffe5ba5215cc781d1f1dfe9aa474ffd5844545ea13052afe349ef5ca35ee3f0be6aa2846da44bded03fff7f603faeee4cad2608a3022195ad5a5aba127e8cb6a6d7b9184eb82c35572a2f72512d5af2587a5075a92fee5188a9d80d7612e22bca8f824d964f0dd8e28c36a2d2bf47a1c38da56a7ad001ea05314d5d7fa3cc58b162b1f5a5d4edfedc5f13d241cacd779e2ad54f74fabc9eb98c707bd84f9d5a27b51bf22d155516c9600dac1d6d3398d87978a796afa460bc22fafe8b0f16208dcfd0726f69f9ea53fd89610cb4973e7a0b98267058321353a51bdf1283709dd4235d499f54f579569e075f8c8823a8893141655954f40ea5a13bf9b97ce74586e4083017ed70fc9ec9f5c7d79dcca2955b22c88f99683bb5a37433bff1841bccc1a2fd6deaf3cbd5bbbe5e03980305594a88eb60131c5fc5d35e742f682703c984254802a8a2825821ec9dc49aa71728e467bea1b383297439bf183db777cf7a890402106f1cdc00629c103fe094f8e8ace2134b206afadc707e6d9732a0c2751ef54700422bd075470c1176336326082aa75ca36a9fbd503ec5ecc1b323c7f813b83205acb13a87dd384289a88b5bdec62a4b771cd4e2b0ef971ee70390425991cbca8245223461cc48d3ec61eff0ad64f5cec2b8fcc611cb1b4ac10214a59014bc965c05495f72fddc16ee8c67c667abe366e7827fd2c3288fb808757b0ba20d66e17fcba7333b91d09ff409e1879e77fd43e679a0a0181cbec0f74989ff2e10c8d0712d5d1ec89227290a0150f0075192a63b18b6dd51fbce9239e2d52bc4f130b01764721f3669a2f6d0f58eca965e679511bf302fc8e001d86f46570930e2f8163f6fdf2d59819e66e93a8d2c5cc98bf1df27443c2e07e3badf8b7cc371dc7ee84f8ce7b74c24eea2d985f88bcebe7bedea9013f5776dcc122ff8a2d7cfcf499fded68585d01db538202138eae23504eeb9b0d19ea861acd1f5e1bb05afeea36094895dd5430c5ce054cb7115dbf38f03cd7cad62957baa0ad6f3cdea0cea4deb079bebca9c45094b7dacc32695b4910b675510d71f7a8fe5895faf2043e74b4e2a3ce87708ee83d2fba1da0bc7fc44ae8ea5259bf60ee8c86a9a2a5b937027b25381f0656775a37178d580aa0111132aadcd6b44a47ebc4aed8c11b51e42d82863ac8cba5bfd9032e06d43dccc46adf00c54b76203aa67054c9b8c53bd22549e3a5f6184327e922d401b9c1d34f5352f8e57f97cde9417ba9f94b329af005b60947c093c236daae2da3f93bc6592f11cab094f34b5666986006a4f0b6ba575039ac50f411373f390773cfc5e597398c4294592c584d2ca333267b1315de556b54b251a6522fd4cb32ffdd39fc95f1ea577bf93e33c2602c7c2a028b11bcb2235fc67eea768383e6383b4ea48f61d4e2aa1e42abb325d88536ef6893e4facb714e454b977accfdc1e4a8b258477d9fffc6ec62758c018f4390cf13a81e81271c21b90d8ce08697bae485e5effcc610034196f3933e692a510f31b9c2e9a603a4130a23effa5f0235b1a9bef929de18aef227e878a2541b519f665fa07b7bf959b0d401fa6cba6fb974c28f671591d46baf9ddd866a09825a1d018f4761d98facd8db154b203761265f6ea575d9ffea0bee6b37a1ff97157de105678b1df69fd0e3bf692a075b7806e1fe597b0c614a92582de2b1f3f5797c64e99d593b5a56fd96d29ba5efc993933de28c059bfe8387b496b482ebf7d7679dd1b6a16bed5f7adf24c08ec72e1a1f956b8bda9c6528f690d8be2639fd9052f2d93d7366fdf4188f2c73d80b849aa0375fbfd9e54b8cbd201d6fa724f19e9596a05f08478ced711a5d728ae4fd4dce38f065a968a02d068b9e5e72a1934b09987033722b77a14feba3f69421bd314e3f9d5517fd31501b28e25586d5b61b98244308bfff3315c324dfa709ab85502d390c7e47b71fd80996eacc4bf7e3efd33602d9ea048725625837df013bd01c1e4d2d984a45e6f2d54aa4ac2dac23b4effaf7a331a27cc2ec33bca9170b6429d719c44d7794c847d9729a6a80f2c9624ccae4ff55671eb20b46457431df89b77b635814b0f3e6fdb7e4408ae1d0f3cde6e0799a19a7b630e1cf7f304182ccca1fb7dc4952759300d43e0cb8b8a3260135ccf67010f10324a377a29d4b0f71e60cccb6a56263e28149892f16cbb971989bb560c684be4d3951405e17a78f7321b392b55e2079657015f0ef51ee6bb43d748c7e739fc5c044cf01a5629dcb2288462948a84b7e302bc18eb0eb8a580b9550a89fb1d9cd5dbf599e32f491dc1a0a235f9781afb1e0e9f9e793b170234e058cd89ebf7725dc3f05eb79ec7f99d6baf0ff03dd1c590db7d521a82b0e5e45d22a038b977a60f8f49403dd5cefd5245923a0b1b346b910192bbb5e6feac5d6a25241ff993142de243cc8ccd4204807bba0008ee0b76f7a444da8d2ad8f9a653ef0abc0a0a86a548d86c289c969d0b7fe2cb189f9d80e4446712ca44f52e3c9049eeec61f81d01fcf25422caa6808eafee1ca86249e9830ee24dd7454d6dd61732dd106e9e2e6bc59a7758b490ceccd4fd6bcb1de397ee23db40cb5e86657dfd620fda9da9075dc82c695582f3ba95ac8591942d35e2539ca2beb4856df5659df995b4a2d3de1a19c5fc3ed98e23858244b9edb229bce32c381b0eea52cceb514fb52ccb04391012aec210e97b3a761f5dd10d49a44aef9a45428772a4a0e774c0aa17e7162b62806f6c358fbc1a65f8870b023913a5b7abeb36aac936913da432e9e5e6d2b630309a0691ce1502cb7abe0b63181d244ef229f67b51f44a888f4bbccbf41d83040d00c2e760a9d4f9defbbe709dcc7fe430c28fbbbb9c666fc9d96be040a1721e4fe87f94f7995130f1e53ef0e312882d6ca9e368ee16bd88d10521560ae1a5edaabc9fddd6361ce47457505e3dd970fc488f5005dc6b5e2e030cb0ef49decf04901e4065a45fedfe6802fcb7c1b7605cd9e97c25fc5441158fec715d22ebac43bc5ddd81393113c7d508418bdb8549a33ec820700d9b90b53273124f83db1c9821e4e208af2f86117d6202628149069ee72de6c7ad86f9e3e62aacba744722cd630039442e1398f7c5d27048c1af0d7b1d2493165df72e8eb09349bfe319ebf00b8be8d6770c83fbd7a288ffab2b3797525ec42256a6ac53c8331c749bfb49df0d4158e511c2117a25893f5d4c1527b2af495c2c49e11a0391e05e0ab678a54220b6abf621a109bdccc921377ccd609b008b0393f1b15b40d2df546a085a19f844c6eb92a3fa3b8da17b785c19c2fe43a8788d04ea0c600ca72a3b6869e34f140a8f012d32cb0a344620c5296c8213bfaee08c1c4595a5f4186b66a6576337c15ee1f62e49ea29531034124846e0772bcd879842227a9109352dd513ad7c29b2d84c91b215c9910cea5f8373105e016300505c8d2b7f34be11573972a201144eedd5bb84e9e70289c62d53081d7749562057959af8defc305d4e2c8fc779066bac3cce31f3bf88c9d2cb3e13fd16adc04408bfae272b7ee5b4e20e13802e0add1372249875b0cbbd0962c88a6617d321e67e03bed96e83d94dd1e943c7b7709b17d7928a4a912b357e769b266afaae9b420a4b65bdec9aceb3120eb77e08a4d4d706c4e5a6fdda53d432b343477e2a694b64786228352d2e6eab0fd96aea4e87a16c3403aee973b2c5cb2d16a73d057340334cbe738b0a4a3b2dc2392408b4e133f976ef8e6e5833a896ba8c991e7d695d026979f8d59c090c88c2be0ed71f0d73a3c73f55b7bee77fd285d95571040c4607bce704da42cd90bff8ce528906f8eed19121388ecccde88e8e9bc273abaf38670b51aed6dd4872fb213876045f172d3491b4326b156e6a4bf5700e53b538720cb436a04ec71183b0ff64f31d9f2ad0d1189dc9886bc63feea982b951fcb011733bdf4e8bf0f9953ce01883bcb20721bff13040e6ad08ef59a3baeef6f88e09442a26d3cff43d41fafb515ab01bbfc615447a296bfbec239b795c295a8bec6bfa933602089711cf94ad2002bc7a080a74ccf4fc1289957e13468234614e1f3f3310c0e7552602d450f314704681f20a35740deeb45688cc3ce31dc4a76a40d14b0ed596e2aa507fc58d72c624dd5eb0709947a2138996c33d157c2801b0d7decaf9af84265d3aec0660b4565213db2f9cfcfe03f25bf42b2d841081035d5f74725c62e455cea77467d7d4e86fdeb517b0c4c7982c5cf1172b02098b05cd4e5b8c17316c13831d3204c9d2f7091086bfa17ac4b2a775938e4ad414da6d319a53cb7e02d4aab2e2faad29abb4ddbc24b13effeaa8f803df028f6c81abfe3191f74784bc21db50b60d6f8cdd42b05d9fe9857fe650d34712601ac713a81f061deb4a6f17dacc0a18203ee95dffcdcff85cdaf8027a70d2d7d6b796f1000ea4fb4f8d0e3f629a7bf4362e6ee92feca5c81a7a487b96fa7eb4db7da5333a22de2ec8d5d8245388d2a57b4ad2e39e460865dcca513e613b60f12d90eccc7febbd9e99ce44d87b9b73c8d7900c3ea405841e54096be254910e626be99e0b77ed7938b3c8c40ea6901ea1b3b4cf87695a68a035271ecb9cb9a951002caf66df5c80289cf5e103ded19a47760249cb9d6538ac4d943d720a1c3816f683d07a02907abf052d180ae001e20039d10da6fe703b6c8cbe99a89e5125b109d111b9af953e524be622808589c96975f781d2e40af4a394f5c65dbf47bc6e4168de942495c4ebb6059eae09921ca70189d6f7da60c7788adc817280101343c672633596eae86fd573472f686e1e807c36744baf1e0e2cbc1408014cda325cc4576dc646a3757813ba6952d6a049bb78c2450daf444ca0b519e51c241b866cb9f2df6cc831487e6a912652dcd6cbacceb7af997cef16553ed23991a05e35349853bdef600f290062bea6720ef3fdf8207bee5ad94cb0bfd23b315a5cb32eb7c3f8b34e073da527ba50c1147af01ee4947dcb6470c129f5e8d4af754befe8848c9915b5177825b09d2e69e0399e58c6355b7861536ffc12d86f80d1aabaac6817c00f111f70af07f88ef837dde8d700ba3a5d42bd4634bc3d70a14473c053dc4f5f7b595aeccff93c1694c4fab94e41007bcd809cd911861b8941df421a0e2b69da1bcf1e732228936e29eb303bd2fbde534ae61abda99f49c95ef93b9f4e13c734a37dd58909381c5455a3620437d9befaeb517c665d6a205722f3133fd6a191586c1acff66195fc7b435f65c1cca47a1bde45841774ce833a2ea152e7bb5f76c6e7a712382a2f57def96bddd812616e36b4d2ac1f9982e69da5ba607a26c18af5adaca0101b986d226a35f31e9219097f6792fd73099f07b3196c9d7174773bac65e48b2eac7887cbe950d03a42ed40850773d9465c280784f6225352c9e9b219a0b881cd8add3df8e05e7045b511482c0d1e560d21fa0b852fa791293b1bfa56a8588ccd10e9a410ea3208b89118c210f3d6d9092de188198f593e5de22337640753c8dcef066017d5de36d9ae3083e5bfbdfebc90e882cb6fd95711dd446be3f46f9f2869ef9ffcf11fa20ce628107fd2693663578193e9c3f0be967ef3eca2f6e0105f81311509f3f7c9d009c69024233d0e2c91299a4f29760691aeeb3ebb72c403136462645939379e3ed4ec8dfaff240e5e8cad682d399cab026609ac7944c392815b1f93ae9685f2c2e998fc01f22cecc9eca1864299458aa17352db575af47c4ec8d664d538967ee80d10cc0b437884be5d2834bd623fea69db6065b82d42262a71e7cb0e5091f1a3e860817176de8b847770c565e446220ee346b0dc79f629a4bc28d763f7a03ae585d6b5884344085095f5d2e27dbd7f83fb5ec634e9cf538604b46e9a9c2b6b5261b46ad65289e3665bb9da19eeefb6dcd197b6aee3ca15d464947e0fc70ddbee82f3c7f0a3707e9e5c14846b78ca87ab80f332ef842a7139d81079c78c5647355b6d90ea772e15642f04099c3ba91ee01368c2c7ee7f61aa6150b7d92ac933de7396148bc91e93d184c82ded2a2476874e73bd4ebfac88a6e387c7aca574a7cebd180e4fcf3fe9d17ccd4ccb3e0ea58bb3bfedb83dbcdde35969444e01ebdfd457a2e71d913e6ea036c11ebe71bbbf12fa3a7a6ac2c8c16ac205297b1c32b915ff131f7baa03ab20545ea36b2dd93537eca2f74ed90d96065f6bb0166084b3e6f64d5b1493bbeca8cb6d0da8a71e6a3045f35dacc626154d4f80ed2124f653a2864d62335c0693cf19f99a1be7a890f7c04ca6e9ecf91c256fc407e90aa594beb283b71be9436b2a1a790435261346471d92d0df06378a8a37b2c74c0013add3108afacb188da4905f6cf7843742cab76569994d25f4c6add122a9f77eae8cd59537444791adb38a9e6fa172725ad88152565282ed39fcb9408e9a263af441e73b8a235b6612573fab1ea4302f330f506d718d8763d85ae07b351cb1ea0679308af37fffd5f9841d023b00c39874507c2ac3352218476aa4adba3fe68c6a8c8e090a1076a9aad06b44f2d70edc90fde36d5ef90c7ea9b6636171aeb88b7b0be930b770f2f303cb3fcab88152da18e41b2e4f26ed805c545ce6df527219dc58e0bb4b9673a735f3282ffaf99f3b46260e3ac228daf6de7eab56c5e6a5c41682ec2208db156c5375248477a7a9375c8833186563f8872ff279fbf6ad7feffcca4b6aac5c403c7167d05b2ae89f968f84f4e992daeedc2577c90bae8becd8c3318b06dc65e66a7da60da23b5f496b2eb727a96a708040c52c9c75b2d5baae31ad121427d846c7444e26856a4fd34707f9cdaaf97eb718e027e967a91bbf83c328e33e7254653151470e0113c1e1d1a7a8b19969b51c5449c49d033931507e24d35decb6cecc8422ffc6987817e1fd65629e21037cdb4002cdc000cbb364aa679fc7c66cc421998c904babdce7788d35442dc3e0b133774a30dead3eb27dbfe2fbe1347b61761261dbaa70baca271d93bf97d78684946e9d789a4ad3e871b91d887f45fb5e1b4393d3ade4e6c9d9be6904ceaaf2fb2a63ae09443d7413f8b049ec439755104b7b57c63b47a144b973c479464a2c8ae64d333529d47b8c16d2155514979513ee93af33725d736625161a42eecc6fcc7febf16051a64e2cdd5539924f65203676972790ba04355d4acafa381bff74eefa53c2f471dc303e7b277bdac4697f87788dd9ff2b6a9f597cb5221a4d570ca04a36ac7f0b8c52dfa1084d256be236ceb6d54129570552c5f800a79a2324b6d04819fc53598f0e78d36bf93a75bce77b73432e1eb6f46f765318ce573ed5a7421e3f864c41afd1575d8bcbde867e619cea32f77a7eb501d8c7f14f97b29c1ae8e67c404996be2cb7cae8fa814243f251c58e4c408e4feee3022e55bff2418ff1c48b6705371fc7015c0ba10a6aef27fba0faa11d35aa92a6788597fe058f29e2d4338e055636bfb880849228866da2b7c556e5ab26a1eeb50dd00c58542541913237013e545fb6849c49797251cb2910e97b9c38165b711b6bb5400ff18c73fc8b56fc6f13423fcee1481aa0ce2e98c7e6e0a2578c6a3135faea11483b11959593579f34aff6e87aed8c15c75cfc2d4aef3a9713c3adf72419c8720e84dc082558e7b0d9d72b1acc88387f1afdee24de6ac14bac17b700e0bbbc74477cd6a51591d6617eee09d794f3c90d327dea246b00e217fb46f358d24157d6b96ed45fbda9c7c49924ab08a4265656266347f51b1738a7662b3467550eda711a3a0290eb6a6868664f1179dee103a337e89ad7d14eccc96b330631f0f5c0fa2a628b277600fa0fcb717a17781db0f455fc14ffade94f919fb79d1510f66651f59ab8e358df008ddc6b1cc0eb56ab8d6f4258cf12484477c2e9abd9981e013a4eecea5432863cf7ec47c88e48a9eb7f3c9e1edddf5b9e3e7c3ba2d0513260a9662b1f9fe50c15e7adc835db64d0e5b956025aaa1ce0b91247f446bd0262457b8d47aca7479457d63bc254261a133e0469adffd31a17457959c76605d6129496c0a60c51af9043e6798f1ca421d25b4a9ef25881e70084c89ca608f2","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
