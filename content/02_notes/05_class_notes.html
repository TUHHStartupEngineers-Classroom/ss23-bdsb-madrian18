<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"5fcc557f2c5954abeb6e3ababdb6ed6903a0ac738d6f9970540503b91e9643d52ed794e8d715a8d7f38f4d9538405c56c76959e7cb0480ad8febf350400f31b54dc9aff6214d954d98b3f13f5c699725944a67f8cbfe179c0bafef8b46c14e74a615df3108b37f5bde20de1538d84f98056ec8613801dc160a8feb88920f1214ca9ee312e7ca29abcf24360e2b0ac1296304d034fd2b79a55bec88e991fd95b2d932ed98f106102529b2ae443224e0f77bc7455e46a3e7e4f78b0367321264d0612ffb64c44ef821327fe9547e0060ea40f084c0198d1a0581b9f9649d6265e12e879106beecba20f66b6e0a71b1ce891977a30f4820275f6579abed82d1588a9ad2de0498052f999a3aceb1692710cc87abc3a4d77dd5dae334535be365f7fd013c7f1dbd7ec7fe14866886048927cc8d5363dcddfdee3c26aae0bc3008c0ad9337f7582049a31c8889495f47dd6c57adcdd063d17306677445310200205c6be3170fec0b9e7ff31cefe3e8bee9dd9d4dbcb399789e65340b8c5266513f855eb1e683495736e0966e3554444235ff77bacdb37f25f5a8eedcce2e7a5b4d94db2a6b39e9a2680f69130e7645dd7599634d07abe0926ae7a534ae93a8a89ac770e24a53824c2fb615b9f26ca9454daa294f9d21a1d0bcbf5092ba9534139856f53e7dfdc25c00e25e5c2bed49af7af916d70cf822d796951e5bcb84de1e9cbbacda02ba8ddc3693abbaee6d2d1afab40106fc7d94081a2ec637da4dff2f76008b6a49b7922c12bd6e067f7b55448447f52513e3d8f3ff5880ebed0e725c5744745f27b87f461638729e943d151f1d9286367ccfa712aa9ec21b97c57dca4d87c2d13cf2f15c27d3e3f9c87d23f2cf1d4d580e0325278e5f8513ae2359fbefd958716d97961b044806e873f1b9f57c4e37f437d3dd6fb2b80f091343da0f6713270b698220cfbdc96176e4030223897876c47fde121c106412aaedf47baae6a89c4144cdf4fb5dc40682c5933ba413cd3aa26cb561e38be63774e286d4dad9b27022b59c5b95bea054099a9a66feb703b6fb3ed48b7c9a60aed81b99e71271f3520effe870e9110d8c491d1ef644e35c6c36ccd1b6f03e0cebacd70761c434c95c0bd26f855568722fd67e1f21f9d632490b9ec7dc2aa7c076d5c440f4d2c5d6ad914943c183c5331efa630088ba97cb9e50682edaec48cfeddda5881beccdeb3a860162a05917962b26c3b31ecacdefe0c9e1d9e62c2a353b42ee7a90a0c615ca86e02f6ab9fc93d537b606e0a7ae3bb4f815217256ffb59bd82b7d619125e0b37ac2cef5b3a7b616a473dfd4d0af8811d681081dbddfb93158fa403d50b3bdd2c00ff91beb00f637d0398211df6fe66df8f2d75fb5c69b3ba6bb8221ace70613f6681a8d87340bac1f80666328e25350081243cf6945bf048086e30f23e5aa6ba89461642a8f3c0e360523c250027ebb3b2aa2a82cf7a70cc1564496020faf0d283703975aba384d8775374e572040b04c13dfd8d20f9f252cc715095a716856de2b145dba0bd8b3e246fc191fafeda9e0f97e66dbc0c25bd05b17dd09b8865a09268e28e994a9ae1d196581a215a90891614fdddc11435b1848e0aa85cee8e33b5b9dff7027aa15ee4610ade44c987ddd9e1413c79529f8ce73f8cbe39646416fd4388943e8fb9c8dfe101adc845514c4c014b04686e45b651149d0b29c986084843308f6548b3380f39bef024cb112cad1e97dc3e676d4cff29e0ba90e51f9369601bd10a431995f069b90ab66f775b6394d7d2fffea7f137facc0143399f9caed6ab041bdad79eb6939292b6d3cf133681560e3c9e8879a1e58f864eba8ea4fcb68be87e9b19d0e7265a536a2d18a3c625f958ee88bd6a976d0be3220ac9930f30fc5a9276eff3073ea3c669270470d2b9c0fbf98caf7cc268b6cabe022bd974069cb07c661a6157cb1a06144bead3dc0f3b3fd4a213b89337828937f2659bbff23418c5a09a047cbea1d470033cc1db1de8992d3986db80c68402bf6e71730d59037e0b6addb665b57b29c51578b995c06d3bd13a3f6f6c783e176de61838513d16daffc456d496085ee27f82d8bf45650f7a25677562f3996312a1a8893024f32e41292905eaba6de7e0f48e3699c9f8dcbe265f6885806491bcf6ad7c575138b17a1df9e1d065c63b1313a2397b02722e700128c966e8fc381dd8d70f18264deaea1efdd46bc07037a6639bdb588db0a4769f3acbac22484dbd1c711ce28789469f3c7a9a8f523df220ed7d18b031a7c30af205130beb6b6fb8875e1d8101bd69ce81e6f169a20461cc909a8d5695d91d4be100bba9b63d43add8ca503941d5fed7f0eae386a8b7f0e3a0a6e1b81d02d1ba439811b581c633d916ff028e87d8417b79ea238f779b4314d4a9f27deb33ca2d2ff672e69b3586d6c31c44d6cb884824d6ece0ea569624605f6cf3f4ecb72a513ab770ad24fd31dd9a3bd7e61daf1338553a1279d01a24713d300adc2e278863d86c9427e4997c515b8f15c7ad37323b289e103bfacc1d5456fb675146181745c3c205da11380033fb29dbfc16a001df23ea3e6778fdbbe2d2c3c025ac5cca1d3868c5aea8445fb415e28e26a2dab476c683b2f059fa17c695808eba8e54528b5c3389021a29795f5e8a40659ec1916bbac09dc1b21a59a31fa1c084986e0b3cbe8f2a9509500ff02c53ceefcac579b4bab92c8a47ca6c03abd4be95c125323be6725e490a2c91358da24fe6a511f17de75f368ec82fc5945850164ce4757d924b81d730bc830a1f07b1160cfa21b08ba9566a1c2341a7e3faf638114975b1c16b1e2bb1a7eba20c16a78cf518c10d33ead824daafe17efb9c70fc14bcffd2e1950df477eed0e28d75dd0d9b4fe334f3c36b1a022a67e84ed4a0339812b9ea14ef8c708a9b228660833cd92dbe23abb527996f78274cdeb68d6ddd7382cab1049b61324f26e028f64e0faf8fb250b3e346a336a5f2d4eecee6963a88089f455e6d7ec29ccda13258de6e330f7dc64bd22df5bafce2b029af35faee0016ff322749e86e5a7edb2fb58915946191b6c0d22ef660f1464ff44c81c1440ac67b9426ca444198ed38178fd76f7fcec2ac5148caddec69cd8c808a66105e89527e8e0e8a96b645cd4180196c56ad2e9a259f23f7a69101a08b0affcf031a183d472a313c1bd6df76b94799459a50d8a4a90967b4d54d2337a8920bb9d6b27a50349e2c158f80ead977467b75ff41c1281329e8fe3e3ae42a9cc279319081767ad7eb5c16523ba9989b85be95e01f3325b08658461965a0211213d4124fc6903f6c9198a40e7b3de90d7d724d252eb22c080f8b5bdf9ce3d59a6167d39c7d6229894749265c63c1951c0c2f36800960aadd148f1f5e62569bb7b9df73c1b39a6d0a26ff6be236dd313920194278451a41ec9a9a5e91eb14b8b5ccd10e93c906bf44d54c2f6b03ccd3e1d43511aea75a347cf0655b0fb14be4b8f928f59d3ad00cbae598a1ea9140e90f40ef72d62f67b62e3942b97a19e1344ef1f276df7ab9ec584a40e01aaa401e05bd28b02403fc7ec152560a3b7595d481080d2cdf55a746cf920992714f7a8b71387471cea835246bee5d81684e4a96bbe0cf1cd708f92471a66174454c099a0ae33e47ede6918449b96f113de149fa254ae601fb8b8f3911fd88d87a52d2ce90bc5564730fdf744c77a2284ec6670b0dffdd1caee78c27a0cc02f576a1ab051dcab563dbdd400276d7e7806c454248acb253104bc209c872dc57d82be33e90df4e723d8fd2a8564e7d5252d261b11ebdc389fa10d1cc4dfded2ba17059d528b894725cd01b8ab24ce335c1f6021f1907689bcc10efa5255c6952a06f15d9a5d5c190f2d75a5693d5fe186008676030afd47105270e638e4c3ca08a72fd66ed879a35bd4801506c5769b1bc3817f74bcce6332efa7c600bace57f77caf60e5621131c9410d786dc018500043f54d4521d1d5ba1d690820e58fb38ab29fb38dff9376e043a54d5e29b3c93e123817d057ebbff5b93e642598522221a49ccf8817526a6d96e1b28495804c7e98136db053bca946b5249c6b44f3f41cc20f5b6f43f1c6de9e408a62387d7950156195a621a25c9b8b411d957bacdf298be70274cd32b1e8646d2109fe7725019da3b1020c9ef595658e2cc4ca2515cce6dfb89f91fbd707bc28d70d69611942a4339250fe474d85b6beec07d756d8c3e5092d6945b2258471cc1f918dea9eea4b2ae8495f8e59fa6384a6b13016b0a3b057bc3aa651df829129b2e5b15c992a51bfb81c964f01cad491b0a37efa762655c49b3a9de93b6f5fd15b757411d0ab890552a5570e992b8086a6469a8a180e35a624f31ef3fa53e2ee7044f4559a848b4d467d63a3671e601470f27f26e3c7bb428ba815e4c8428dfb8c4f3c60db3bbafbb80bdf251cf5dac97331ab1a4c4d154bfa3239162e296d8f081bcc02677a15d83e68d81728bcdd914e9da538c82961d03ec23204cee65d57ab108f063f8d5cad2efe13aa6f0ef3620186572bc8db24e7b4dde3f8fb950f9b1942ea609162d1ca3e60d92ebb14bcfab99dafefa8a171784829eee4b92c7ebb636ca5a09ed17841be5a249da03c711d0d16e1d84d5523e8bbd85c48860a7e87295deea4d5384f7e7469a50ac68d5609c0f690e2d81c92b127cb11889a11299024bbe1a23f74c658cb0473a85dee4ec7c97bd8d754620912839163bae6b14be391721395ebc0bcdc05fea7439517cc09544767418a43b8b37d23dfae0ea1a1bd879e03fade32b6aff43dcc0dbf7dd5aa445d2984bc403fed2ddda2dcbde7ac2114bffd21c13e951974defb6d6f74bfb96a624788660dc4eecf194df9ed29ae9ff9db3c9f1efda8aeafc4dd59e36cfe19071e0aa965bc20fb365820f921fe40e5f2606eb3e900a2939813d307527cb19c411658de2bdf1098e6390212e11ff071550f8e3f3cbc756f194a5c23bcd7d38e950c660e06b4596ca8ac3c1f86fbd8a6edff6d24c5682641fc1976113856b9005beb70e11e4dbdcc22a943d52a258d140223937eb5c9fd31757ae311fac4dc39a8efa34c344b95f88b3137f641e90b3628e1a4783918ab578de53d7fd7bc9f3c105e28c5028620f8ae31eb714fcf778d64a833b8d9e113cfc7c36fb492ab076908dfe99ab876d8fb999963b4cf6d62236a71fd25ea1f9ca7c879192829a19651b77837fa9d6332fa06d34c87da9b3c86416f4062989c71035a9935c80190fb75d9def50f7547ef90c8e4e7a6d866eb96ceee220c44d75d2cca2a8766bcb1eac581811af45e8b8bfbbabab009029742249c1c6489cb3ccc600594dd78b0811473540ac30f1b1c10ffc63078df20857da29d1d08a5e8b28e40e771e68b2ae31628029e834da03e4b8e5b0a52d1e6528a8b77e22a414f038053707d0982aa6a5e1d4dad895a9c4aa2219df3391138705cdab69ad4d31511dc041b8145a85e01c113484b2929a958898c459b4bc0085f809e9b48046790d9dbec631f061f95429804ca7a491a8c3c3e83c490e551758d866823bb0a3b449e38e8383c1cb453e8d9dd9fa14b1b80bd75b4ca3f88fbc01dee0f299002dbbe1fa8bb321b09a64b101c40dc479d3a82826e03838dc7526b2b3fe42247c5cde0377067e055c1a002c156f7410ee104978e0e163046c01873ec712616b970a21d252d99313fc6f3e5f8918cf784e1e8074d666abbf62343ac1e42c7036faaa742949f82ca9ec6bee05858aff5baf5563277241cdadba31be5273588de44a2cef49b74daea0b423f5f46688dd8f8c2fc3545f125edfc79659ff04172ccf0ff009524e859bcded67d65d8922cb4e5ebbf1b4759c9616790517bbbba5258c8a5df5bc2febbd582eb259c1342909dfb146e89f926c49c5f8c82dabc9fd984caca5cdcf66cdb26c92cb9512f9c5567135929a09d7d110f832b0f389c406f7e00dd2eee6520e259e641651eed137edb859ab0e575bc48142bb3b73a444875a09ba5e003d94483188c1442e5caddd3d6bf65a46d2b1aedd73e0e29e2b64a40835733d5bf5e3f192d2c0f0c4899e01a257ab21c8e11c1e353c2cd15e6c99242348e01b4d3dc2f576d6802359ef7512cb36bfdda10f8e2fabdbff799d4767c0833d14671f725c9977a86a13c0631e1d11f02d3ea0bbcdcd191e37887e2cc704e77779906da533094c8b28644e86076f892ba0185fa8d1ca98594895b2602a3a831600a8f84a717b6fff2cdfaa7a27c7a1db5f90d82a58db15b114a64bb63262f0f60e9942772c3179b40fd621f0f83e9622d48dd39f9208c72aeaefb90d1d769f670e116abe608317752ce0005e9d30201a7081e0849abdd0d2f53435599dd6b685ad742e72095aea4d1e390dcfb55e39a510e64ec8a4d59c9742e8f9168807560256028be3a4c39c9ebe240e2bec0ae7612454fb07518ab06c136fe897aa8b72c837d2def37b628cd5d23dac78faf1d0e60b90df6125fa437fc7f189a22c0e4c9b14a36f4d99b9ce5624368c83f65969d347d48a68b163d69631556137af8e4d06f2075230af7d38668cd75d3c983f274833b541e4361b8e37a789c9fd37fbb988566b12eaaabd46ae8b59fb9524ef181d7b648948e979c04a9afe16b184c48fffab2c720edbe7ad5d6b1a14073643f934cfbdc4be63361993fce3bde765d9ac22f2b0f2759f37c58733688e4477a42fbbba7dde4aa98af94aa5623050fa5dac5057f9ebea849550778b1f8a5682ad7f64b3f27cf42e6a35bfb80303795aa546bad8919353eef6f92d864f68a10dad66a1f5f4912b14e89068d9dbfa002a4d4db20ffcfef2aa327558a2e5e5ee567c3bfa5a2eae9c6b3e88991f868500f819fa7407cf8d707a582f613715c76d1995d887c687480ea81272c65ad7ade2469b2876f393fdaf7253415d2f1f2cb7a10f43d821701406343b7c561a20b14b0c0a205c36a5d9506b7aa48daa3c41b2105fad446974e31aef7bece43bb527f6f3fc361aafec4257910288d769b270084cca9b39cf6a0a2bfdcc44d63a3fc9f7eed72aab9c10f513be2fa59eaf031da2f6a16d28444b3cf90bcc35bd42e16785071267d9ed4a8d7eecb6f5ae8dab21daced6140725825f69548d1ea6846106a42432bd6af119dd604017f0f1a00bf50d284489c6dc33baa0183719b0a270b219b3f79b642b22159cbbb7852e662f53184157f0e9739da609754a4a817b5c0428c606c6e7dd2b9b4d368553f6cc0d90802dbcacd582b850607efcd0c2b8670efa50d854555e54250d5a9d083178c4f84d0d8bd84239e60583c87621a6c9e6d62e0efb510e59a9ccb3132e9e3e8823687c96a5d4739b0281ab731f584d8b4efb30049f9a5c82408ddc4cfdc5a2b61ec9734081f085ce5c59488bc42243e1d4f39c80c7e685da504ba96196d3a542563e29f6a489c886cd1a40008b465a3af99dd1882fa6256b89b944f1eba68f969bfcea3059ce6b4e16e030d60d92ed8a9bc235eba8f2d4abd597867df4b74a3a133329add0ebbcd946d4bd35f2fb43e1c656bc1757d2d4adfc1f8d31f019c6e5862b75b7caa13bb7bbd12278de266a4819506a8982a85aa5b140c86c85eecc1a27bc68bca282239d115ec4f7ffb2d8de1d9d3f2085e836f0188650495f6ef94ed79564ea9866437cafd5bd32460aa7012feb80ad101680b4f7269fd399cf7e877d68ad2a946e43a4228258ed2069e692f00248cdc84c187818d5dd0a57283673c589430417e05f0e9da04947617af2cc4f9790f0dbe89c27f08de23ef9f54341b18a44b4519bbbe493f03954e87c13a0fc6bdeaf3d3569b2d1677527ef6eda63ee04a751031ec16e170d028eb04df303eb294c7c91d2f0026d1ca51d842499e37b909772a08e409935cd3de2d1e696e18dc04f118501e76c50cd427822ccafa2c5c48f450f2e3b4b8a9ac33256bf0c8fd9126507df0623c3cf6c17250bc223b988936ab80a6e874a0199edc0894bd8a7620156bfecc03461c580d618fc362bc1f0f481f212f53d0301b919faf453cda479bb7c50e0c5bb60e5e65be206d5be11337cbd3ee2b7f16c94126c84215d68621f061cfb21099290f6540a19f6cd6d557f08f843d1b9a3624b20a34c6ba89b496749ab165231447ea49baae50d7b094e5f2eb53feaae204e135ee78ff7caa69857dfeae1adc44c71c5d9d6171b32e2628ab338f58097cfe5e8b83162f519a4bbe8ab8d654e8fb5f3b0974e89ecd7bb42a10c3678bbe4761b63eec855a5d0bc8c737eb6a1bc8ac9729b26a99b4b9a6f44c4df8bdec0a65eaba98606c4fa0bc9bb2702b27713b22f9ba4c0eb8b35fd12aa91c11e5cf1826ea8098aa8fa05e3f8cafa279ee42bc4f197b401eeb6135ba2c1d826b1ac126311b1b749e9d248649fae6727066651d409da3b0fd28c8bfadc781d2e2321b872f00fa2ba0159173b699f7ed392d34483552f10e3389eb5220d78f8acaf46c162ee86b61816ec9b7125113ae9b0e80f3fd7c064ea3461e3b605a0555ea90f654ec380822e9da0ab01606c3b8bed65cc798ce4a08d1854f04da6c21d3dd6ad5f1b99320f5fb3bc721935b626fb109f938385b3d6981fb8539f650015db2ab9f7e63690e29823d3a35e1b7f37b98e84b5acf64a0ef3cf3b2ef9947ad10917b38bcc3f302d13e58f53d921a8da135344ab4bcd2a70294d460a620ed9d697a836cc55fd5d366b11fbb60d530a27d2058de74cd6ffe099714b54a915c7f0e996bb88821b64974972cb6aa9b1f816b219615d2a2a08fe92c0b94ce0c434c0587d001bfd28f2410de322d8427e3afc58f6c229510da536f2d3bbd37c72a4417ecba0cee0e34e86922ed744b368751aba3be9547f9d9e70cf818b06a8f86d52c53b10b0596d8670d9e9860e774420da43fa694a0fc1e725051fa93554648a6e595b6ac6a25277098eb60891cb0435d3c40c251afdc62651619e9b214709cf5f3d77d703c4d26e687d1a13d7d94a25111ff45e4ae9e5a11adf4645ad0a21da42d35db17f6fbacf7120628b79a9234c3b69a6743142df29b2f3c9133104073067eb32a52bb576de0a66afa53b44dfe2a9622a1d1726d303be3772b0df09acc6697d09a609d5fbb678a0605117c852ece59249511ef47c3c21df8e3b4d40e283bfa84051e1534ccd31ebd75dd21e924e71403fa7b8701b7356c30297d0455d88babbc394f046aff2b03df3c5d95c7ad1783260058c3d4783b1ce192d96430a814de00140cc04054aece16039973096f2574ab9328f6b28912f7be045625802fcde038445102fbd75bf4a09ea9f17815173f93cf4e86e5d6501c140b468ff3ccd2b87b1ca47edb20ce489fe7064a2cb6f9a5b9cf52af8486533752472fafbb23c84bb66352257af67a3b8d73bd93266a2fbf281be65259f28ce284df44cc0b3b37d67e21017e09dfe33b2be45b1e6d5026323e76d523d0551c9488a66bd1d1337b0154c008199fe13e9fb0400799b4ccc216b067ae02557530c9d84fea98f477f8dfd813cadb476473431a93b230b0f53190e8c9ddbfecd817f97fe56fd3ee73de5323c62bb9be040212b5e3a29f1c049b4ca33fd9775bcc46d7ac2d38585fb270eedd4db9880d5bdd2dbde9bd427f04d677ced94e082c64195b5330fee029c8bef0c6ba8ec9e971d2b0ddbb1cf2abac9a3bfb9dcdf16411fc2a9903afc792c545726fc51baf01b0578bccb406db2fcd627e09a3af7c227806520d59af32edb749a76130efa4f82d550634f5bc2f76f026ed4ad81224b5a73d0f030a9989d7dbf8d57d1efe687ffb267fc92580d9da02561b27d83d07f2f4e899ff7ddfafd3d059e723186d0f518180e2b22f454eca9ca15f97fee53c3051bb84fd805675993ce36b2b8a6716542cb2a41fe7cbc346e5799f7d7e73fbe3d77812f88a0a45b13fb5e6b33d338ad23eefd605658050255520b63cad54faa4604dc0a4547cfd9ae23c20eb6cec8efa0ba2b505bf6fdda54a35927393816bda72d914952d52a217f40b76ab86ba6d336f98d7a21579664e23607a6875bf60f53c8020f9596dbcdd0ea65dd8f4b91d8659b9ae1271b0e4d45db83e13894451b4134f698ddc791f49061e918ff26c6fb7cea50d854ccfd3182e551746ba5bc2d124c321c945c791e2bf4458b1ac53102f53bb0884782750e98d3b4a57d0d15f0b58cda155e6a68f306cedc493f9545e9b75ddff6be6a9be0fdee98d9d49b5f710997da44a9fac59a466375dda2da541a651710c6abb2bfcf9804fa78d28c4bffe83378f8e8954b09f932e36d84a73ab1e837827fbd57a54bfbc5f34711fc3ce0080473d9f4d9f2311a6b158280bdad6cfeab09e8d61da9d40591e10f23de37291528db1be59529ac4927f1fabc350d1bfa3dcaed5c2fd8ad1ba38147b8cef86ea93e9f048cbb58e7f3b62e1a8b117943dced8bbf09d13cbe507455ee21ff8ad7134bb5780f7a9a2de47478a91fd3997bf79fc4e893b4bb58587696b5e74b94ab34eabb5a6fc2e5f9c02dd95f0d02aa84dabfdf297916463488b98b2b05a75ec51140cc29c263c747230022c86420888dffeaeb2dfb406fcdb6a18838733c791fcf41c2ad819c8633533c5b63692cd7a943071a0ac95e2a302448182adfe23e2d97e76341a92ee367f2e53d2fb961e3ff969ef56670d08725540ba391501bd90d44c689db19fa910879d8671447a1a2485f7415614dc542bf218cf8cefd097cb07deab71f4f7dc43a1f5bdce2260fd5ebdf5359a86a338e9d6dd0b825bba9b3220b42c8d1623ad881b94e97047632128e6d460fb2e9cd7f59127bd48c308ef3481ebef1e3d3dec634cc9549a9bc61f6498f251b148a12d443b184a3e04f6eeb710591e721a26fafbe4ecb565f90221c427b0f01c0bf74cfafa76adf6cafe8c75bf5ae2307caa84256e488ed4f10cff25990fbff2f2ae2980c33b79fb89dfaa3aa038a98954b66abd745ecbafd7fd9e11d2e81bf14e1b121660e1c386c0f6d8b0c9841bc57563a15706609dba3bd689f25a1604a088504fa98ae35646efbb115486a669c68c96490046361c359c74ed143b765b0e85879bafca9f1b19318ddae36a817dfd35d9cdbc37e5d5dbca51619b099c8c589f2c5b9f9a584fd7d8fc111bb7bc1d7e486de9959edb93b629bd5afedaa456b9955b6894b61a505523a3fc1b7b0b7c95574d57a858b9577c167f77cba1ef3ab8d98996f7547164a3e6ff2d3cb908abb549c9cb6ce0273b34206ebb97ea38f518489dad073b980649ee3b459b1f8cc501c25bcf0b3b385bab83d899e227730cbef50643788ca0a90397c599097c357ed58e7ae821f4ea302ef3f91f2ca45cae72e7e10f052a470f561200d9f8a4bd7720aefe17aa9bb5275f2a8fa29a468f4e761dd862155356d450146a201634df35e77d8cd5e1cf4202f2338b038c8c96bdeeaecc75a7213f618a4700833b17241bee68a74dcef154ada2fffadd9d2b7f236a658bf0b21db193f23dba003b4b552822e2df3c6fb1ed88a32ef556cff6f12fd83059a18637eeeffbb1bbf5b3fa7aee4e66fb9f47728d2386b957992b1f30104f4c658f332af097b682401c93cb83405b452294645e7f3890eab8367e2e25c572939ae9e2702b450d011e2656dff40c31b33e1ae02fab021a588ec98d1edebf09b4705bd7559b4d09c9cac1a16942fb0e05a5a2edf7a376d81f10f22c9a91351e7830cfcfe95abbd0d576050781edbea26ae2363bcca3f580492aeac413ba021c45ac1743ef128ac0521fbd238aeb0e4439a8e4f6f1d94f468a57fb66567131614240b1563f653fee28bd9575eee72033721231feeea575497e2ce750e3d721af334a209b0f3079ebaeb4062543adc6d2105cdbb370ecb2ae7c2c92ab41cf922642c99a7dd4e07f2b262161911e96dd737d6f8610278dd4c25e8a2408cf8f95fc69bef468a243547eaad19c72c7e561f302f66f6a80f4d76b314b8fce8607019eec370d158244014a557fa630589c2f316841dceb7e1e2a15c98c17feade54aa4a7a8ecf002b6e919204c4eebe1bb0d3b72b2fbf828d26ad10f58119945a7a4c1980da899532fdbe33c74372ca19078810f6c9a0486da934c4c5b6532cf743c186d195c8d52580691583bae1c6dd4bd63a42168e3865d5f37b204a58aab81b79764a8b8199ad6ec413d5d65087ba5e2b84e57a039e254cc3e4a7d367c17115f166530ff919dcffed97ed985e783c4c579c69a6569b00fac0aa0e2e66826cf6076d294bbab16d25035445e59b840fcf12125f6c12b54a736b361333ecfe31df8b9375dd4b7b42a5efe79b6ae51ff274ebd95a0190915a57e77a2e8349c09523c5173137a7b156f395b3f1a44caa6473a0a6036d064ec3ef4d2666edad7e8ed9d533a6e1865ff04eb86922845fbc1916754ffaecdabff37a53643a12ad240779a3ca9612e4d12c81883c8495dc8bf740cba6f61ad73a1f978eebf95a8d87fb7612062860256d40009acd9ea59cb1b53e243d8a3febf702f9fa087369d3a008e32e4e72bd284a404670aeb351cff90e8d5ad141ed07a3e7c0fbd809b0605ed980f97235f91fd4d7c056fc491ab23cecf455b7bf4a9fa612b26b1b381c1425ad9ddcb2e494b885d19120ac991da5ff84be1a32fb1b872c7f7aa4982b69693ceb5f17366a6ecd282bcc98ee784a3123e9024a99a2660b8bae3fed279f7998b2de6982b349784ce660b7991245e784e5b88897ed4792cef77871ef36ac27eaadc3acf4465e1a26d7f16654b1f88c2dc25fd1b53cf98b4fe07e27992ad78fd8b6284575912a75b3f6d3e4cde8bdf93dc3bfdcf45996c7ab3ba6def9bfecdea191777df07c2546148de1232bdfd09694b92f3234c9070054a184eca1357ff4b36dac8c9d83efa54e661250923d62fe3275d168a51b9ba709bb2355048a4a1370a3743af7a9d72261802c198051ff33478664444b4a53378878785cb8350ce7c21337a5841ee55f69ee1b70462b02f1963b8eb4db816c762cae372e9298743840a0a89578000ac78dae5721e958526285e27ce8cfbea8e978c837c31da4c91774903e2049d9321b09ab381c9accfa0fc67c2f05747a0f7748eff7a2fbff6bbd0678b6c44816763d103a7434c4f1fc26b4a906bd68d9970e4c686ec9215bf48f71be4bf221194af032b5da7b438c57080a22b17dadc6850fd36a4a6d29994915bc2b2205c078a6ade38cc8b4a138cae11284407ba709c53e74dba86fdee64aa5c8295bc4b1f5e72af8d41b5cbf5af0ee01fe8574a8b2e91e71dd6228f8be12d5ed17b87082daea224d0c911520e0efe328e5f789d8669415185f504ea16c03e15dc2ea6c87b37effe680a8bdde30a2715936f36080284071b7fa336f6e7cdefe40a97f69de081b22c6b202c6592573695eb51b0bebec8e5085e1c904a220da38ca06f5bb49e115f9d64f35c82cfbd76578b2241c11a42b8f546affe1b10dbb97f26833f3a0e2eb99a14e0ec90c747e38d6a469b32e8582e9c74491e5420c3b24be6c02563be8c731256f7dd38f8f8127aef7cbc082f4f0cf5b50990ae050ba6785db27e86439814ddd44791d42afb2518ae4490cd8287f81811e67fec68cb68cf2efd8b2066631045ddd0cd19cb2a692b2160b3952ba0efd06d2a0fc3d0f528aa740a5b25b81b7fdee35701c4f612751cd45c56ef5f6c536303c7710f2bb4a1a2459ac27e9db7498846f7f11f37f9231c857537e1f6b4c172ed644c000d87da38849f11a505f3a35f8e50b16d4c82c6fa73036e1c50b9e753afcc761f24332fbdd14fe8e88c75b53df6e17cc3b648dab1d2f983e6a01db558a02245d99f91ddcfad30cdfafa25910243823526c55d9b3d024102faf826993decc5a3ec0fc2522c6e2669f721965287f7af7c9168e61bb69a5e0f274ed731bcd6cbfbde0d0c563983333d2ecdc7cc0b61cdc70f0b74de25b012c10aad4a52960688ac051b03179c818d3f2b2716cc07636a076a726c50c5a1cb4cba81524cf02c4a84e2a9500c9fe64d2c356c8ff14ee26ef17f898b0d82c1cd12bc9059388d52eb5cbc37e0808f0a8138005124c7eac2fac61a261a57832253605d58aae2141b9610f640833541a4b41c4e0ea13965b4fb10b0cff0ae99aca09951b0a98a33fbf419f0c62d73edcc7369fe2e59a4a4390a0bee8c749b0220f6d37454e0f819c0cc3175f1753bb54d395664f9107328f0c0d7b4bd63a42903baccc6f747714fbf42af94af1e19eacaa6d40589a4b71d4c436ef1570ca7f8fdd3124381030011ae68030e00d1c64a219fa1a335b8f221e9b5abf43a056d28ada002ca0335c9fc5edff6f7e53653a4e5ef96e13f92ee73e7bd665b7254ad201c90b2be792a370c41ab0e6b489ad7e3f2b7e6fb9a8bc0ae8380ef63f67d755b8d7493f883857202a0ae4781f8476e32c2a219b63974f1a8da024df4c5daa25576814e3a335fd6c5dddb1fc060620018c30819a80773303038f54bc9769919c34280cbbfad30501d538447f18a4be290787364f9ac8574e346847efba036df294496381b4981a876be458f8d6e1d4cbe7ff1f6f5a0cfc81255704dab8cb04721019fec15d8088977270b7d821e1b87b3e7a0679f05287bb321c1694e595cdeceda3b0c767d3c517cb7067442698c6eab5f102a3cab41159965ce8ddd378f224d04c98be1441cfe5a5bceb8476be76c05cc67fd2ada5f251c7e9736d96c0a7e8918928ac914da4e8ebb95fd9986c14d3ec2c32e99bb6a94a31bd490de89f493a2b456137f002824a7084558bc999100c3a965c038d3cca0defa362511449c61d5bd5c1b2b29bc83b632160a109b475a4fd51d04721b921d16f0e1205bf304f710d0dd4eba7feffbd216edcb52fb0d733eb210e428c63ce3bdc5255631f1b3c3dbb7783899150056c78fac4e956285b9021494cd07283db233bdea464a67d89ebc0bac51fdb84a7d7479119908837177e283e2ad22565d5000d04ec6d5602cfc8181bb5ea487235c2b16b800fc24870b242b6697e4bd8f470ee929d48e6360f3f8466ba241bbc04a33273c90430ac4a6464483b0a47a949d1f9b5de960678e36dea09d3d5a8cdfb720c16b432491456262f3a83df5bb9f92b8172104b14d292908efdf1d9076b004333e86f8d62d469a8c0d156ae77a5cd134f724e7582c1d475fbf19e707294b6981152d37da0ec3dfd052375016db40dd2e88132bda563fd3a3f06f1eb103c883dc72b1338b17c2a57900afe27bec88cce1936cb323ae40950a805d38bdabe6a343a35870c9783af3694f41aafcec181871284ebc79f23f9705dcb7570f9ae9addada2f86c577aa1845428e1d453550c9256ec7c98575d7f194edb3c1bf63dd0e80ccdc03054b3841e5b905a0d02c6f13f1450367b3f2d7b4d95748f98adbf96e5470cd0e5d1c176a8559e0f644b42758f75f78984e6a664ab0d3316b13784282fe33bf820226dca5d3273c1d8977299f990c887f8b9bfeb5276e41bafc3de2eaff82947741ce748546d10a6e067b44710dff3450d635c5f839e1b1d9e5a9b262d1cc4b89f0bc76c4291529f0f3638d01e85a96a6f6918f79b3fd476c63584f7c077c8d7cb1a4f51aa8e54bb7546c6100ba65c7ff5c0f939949788f92667619ec6755ad0ef0d031173205d329a76e3df3ac99aeb50c719923f005e5e651919b45a7056662a53bfbcb214d3c0194cbaf9d1d8a79a5246b0056da532e7e7206db21c34d6a0a150508c99338ae9d42585142519acb8a7f247f36ee1aefbc649021ba74cc4c2312ab8d7bf603e4cb802ccfdbec812d9e4fa921bf6e083d10b16630b87d7e878e16b2bb9fad6a5856bb2ece53c47d1b9265c8991a59bc14d2304dfcc00233c8b7ba577b7e5f1c458b5f66fd669957774a33a4ac5a6c5127b5a0cabc7c2ce5b5c03dc237d7dfa083a9579a03da7fd702b08e7a71eeb59cfc93aaa20ff4d2d42e0c3d946ee6fb3b1f098a689bc56b89dd3f844b4008503bf97f82045e43c7082670819374648539d6c570015bbedc4837f7cdc99bfd158b950e92d5ae78d1844cc24b7e041dacfd3d9828727f989dc133044c0ece87aaf51c411ee3e4fff691a38742610d20f2c43ece014825bd6ba84fffb00ed22205cf56fc8a32a9ed47f5affeaefff762568b082603e653d75cad65218df8ac97e05e91acf6a2347b42bdef02ec450043306a6cd60dba8d8feb73b1b5ef452bb631d409fd01898a0b9a143577e3d3307e4e24a518f51377f6dc7fd643f1641bdc9202f11f96691d70cbd05619fef92ad546586c470b97115ae3d01908f45fb45baa00f16fdbc4de618f0de87b21f36452da10b736f71ed1ff79dccc7367433c0d0e47a33ca2ea6760d2a1f6c7c60debf84c26d3b4b90970921df48759840309d1407adc7be7a0fccf49fc008847671c0665c95e93e88a3c609188a14987f382a4d639420a82d701b94d2b0ab1d744d513092951ccb6508b3ed10dac4acf5b001a408abab679a13e5c4abbbb3d9565c0f756d56eb5fa5facd9510fd5163b85943ac8545beadf49f304639a4a0ebd067e91dec5b7acc7da96f6f3882d02cb4cd9b0bf8a30d251d8a30308585a2476e7fd7f45a407add6841c8ed46d88477a2469bf9f97522cdec42bf95899106f9a0662264ce9e68947387e2adb30c2c6e6ef1aafb3006f61e95e9a2c32324ed60a33694a2fce91053d5ef6d89b7391efd9a9a8ea3c5f5f0e9aaf5fbbc1f6dac13feea9b3c8e0896c860e52bf702e2c5786d08a95a4a6b06f2c51460c4f1d03859d7990619f9448e9b07cfc977050b12481679fc19b8c1a585715a7a502fdc84a2d599884c36ebd59da468969d447c84439219f30a6925d4acaf288a0ab7ca688071319dd72ea65f5274fcd69c295d57929d2ebea0bf99c4440bd1a3a96f59ec1cb4c46f0e451cce958e844558c46782de96d1e81ec45bd41da7e3ec97f2f1fcd8aef08baf4e53b8177ca8f3f48611236feff2e3ebb9e78cadbeafcd065a7891cf5bdc29582668745e4356ec4e77c83cfd8deea0b499557a7773711016d2c1c4cbea2bbcf2c80b414f924759981d28434edbc88bdf25c5cbcc52b0c42e895e6c93d20774bcee6b8a2d7ddfb8e38d572dfaaa0829b7e498cf677c100e75c9375300ba477a233fedfc21216cc0c5ff7f3dd2d33ff94172991cbebdb5b39136f254c35f8b6c0def34a46ad24fbb1c1015448e5bbb6b7acffa50955f15a8bc5d89dae820717cd16e00422a03e83b8dfe45098a24c3931cc3f6969ed9335bc0b317f70bd41924f8c956b295334f0f18adb04b8e4a326e91718ff3dcc02a05badb066d4622a4289dfc949b2abcfef038b69c7b51a8dea6803c8762729cea88a63d54f1ac396fb47e794760a2c3203954260c2951f2a59a85127907ad1c104c9259e353757daf86369bc6c741afaf83e1f071475e5d6b3a542cb04cca52bb5be580203973710fb79484e14cb2d8d2af09b03c44fd880f5d1d79945aa576ce4d7138d7b7b41f0d8db2979376095086cd1452e5e61f24b7feb1bed49a365df97cd26dc7047bc4afe4b083d5e9d731945284ee953654fd7ff69de7599cbdeccb279abcfa7ce480fcf1a341e709f28fdae4a14380bebf225e7c1480fa9e2177acfc168861112d2210cffa30bd818db547ff08bf13b59379cb1fff7ea4291928e1a8194f419e6c9d33a048c6b0281c7c92d34721b78df469998c450a20c9a9c065679c2fad32c769e34d76bf64a11e5003123241113ec674338463ec57e8156a7a6f0c05ff49a138e0f4a3b8423db6181f546abd751950eef21bea4600e37495b9582a54d026911be58f3b45cead9c2457e7e41a47e56fa4cdb01528d577f4bb5c5a2defcfda66637ab8f089f8b9911c979e179da1b23e580322bf660cfdbbef3fbbb8c39df580eda0afd6f8a7b4936ccecc3c25007c74783d2fdcff7216568149cf716ca692ba69e50e68eac88340374b28bddb9a0087ed0c71ec16d16f08175596a0d55a07535e5f05a809589f6c5183c629eef19eaa4d37fab6f107cd7d4360dc6dfa1acc16baf47b9d583e9836da2a07ad4686e8727425d6b6b073522c6fe5efe2d2c3fab4c95ff676472dd65496a9470db1fd5a0ad3721e8e8cce073b116ad51bff8ea6c879c23298ef05c9d1d2fd7ea1f09893f6783ca8556077fe2621ea37381774e8d1a429572085feae3a379bf327309c42eac422d40e6869a1c507b7726fc9cf055e863e8a55b8ba0be4df29b9a5a6f193e3f130c8334a55fde6aeb9e294a21cd0e9f7f337bbf584944e9f442d707043f241bb4cd89af72ee05bb7dbe2b5b3abb9416f2727f650abe40181a3181250ed6cab6a241b8b490625009ac0a9576ff54bfd526e0f9793c223840c9c7c2223267f79c8fe8794854b5bd55609d21f142429621c2fa57dceb6ac63889191a806671bb4db05f7e5ca8d2357d28ef74766b08733e9fecf7760d0301429963dc8cc40819ea307f4cfd1060496e6d19d892bdbaf1f12dfa0e5525f31f141ca49398effe89f3cc9b19237caed7f3baf26ab2d5d3c5cdf2377ed2c2f40c1b717cfea2520535a71d6655a5699c0e68ff0ba4cb9d3b48ab92aec953b99c4c6988cde5ad4c345d8cb051ba46e01df8a4ca34be7dd2cb73e43ffc7f2ee1e2415648c7d23714b018e38b0a246c135e408bafabe1fe7fece0fb81d9f9e7a04dcbe0ea23353f8614eacd681d3cd5fe1b8b01bd47537bd9f8af0bb1a1b4a36f6ad805f2adda3cd03c81e6910e0e4a223fbde1839a00c438ce561d9f8d5629bbb22771418f44d10c57ea842dd2a0e60ad279eb3bd24b661902fecc2bade6b61172ede467b4e1146bbbcf34e41792b5d1b8fe0458c745b3f2abec2b80694e32fc9dfb5ce139cfe58b827514d7741a5b5991bf30bfc3f1dde372110d663008e0564eed647e707212115ec0fc150b07d7da64aee45b3e350409014c49ee9dd7d5b56d1809af7883781437cc5029cf84234992140355fd64aa2863b1126a63d56ac2309fae914c428bfb7a0979dae438bd6ef93bce6f2c2afe29ebe5a983011274e65d9d756ecadf7940e9a0c563218a71d2311c4e63bafdc637fd9b0f028744cd8fde705089587f7a79b533dc5cc19243567d3236326a8958138339fb8d6f204b565610159b34c348fe0ec5a02b26169f4b7842b4f415dff05160f9d248bdbe8bad735387f1cfb77c556e0329a11976c390b390e7c30e975ce3a46299df7b78e10f262f41cb5c2f07bafe3d7ec5578f2357954a3a404afc1fd6776a439e69daacaed4b3b4c442766fda739046e2983f7d335471af497a563ddf780f1868f0b4d166c0e4dd45014c81a54ebdc93df481bb6d9dc2ebc56ad7f16f52ec207eb932943b2962e2ce2dca549b88ad87596ffbfcf4b8af6c0ea5ffc05533dc46863f4808a327f2028922fe8449b47030f91b665317ee8b9c30bde7bb6b3430a10ef0015c4a657401d3d5f8ff7b9bf98ba91fa1cfa97b4254387a3f6fbf668d6b21c95f63e249cc970e49f502273867f449096eb83a4e44e56f2229b63a164d4e7307e468d0ab2fe8bb909eaed5cda9df53751948f3a42a0adb86af9c80dc7a90eaf04e3e377f5067fe69d1da9f8d7b7384953a9f75b8e5833bc72a2ef06eaea10c724b3878121e46f392de03b1ad42b5a6584e0c9be739b99987979b036ff6029e3256127b59123a06b3ded17d57a3fd7208aa4c4c0fa7d7fdb65bb2ef306130b8ee7dccd070ed9d5b9bdbd1c4daea7e3bc8906e6dc2e6d638026a7a0da5a1803a4170938396f3fe7817a9baa6c8bd512789caaeadf6a179973015b1b79413abbee3d90196b25c310712f4188349a9940a5d1430cbf064f7e81f7040b5ca6b6836b852323a6edbe0f95cde7bbcad7f1560c7f211643dac1dc1972c6ce2b6eb48e1670a20e62185dfabf1235393ff4bbfb1ce8c9365226883e93197f965c420c6255dc4092eca8d8c75f617000fd276c55fb9eee887cdfe14ccc0cc1f908fa8d664ef1187ef2122a8c138fb4b2daa804b2bb0e5b6520d6dbfa715626aedf7a379baffb69f4bfd73e8ee1b134441f12e230bac03b87243cc0ad5fe8796eaf34ab83f92b6099e168012c3c8a216a95889718eab68f9cc3c1e7b04b402c1767de78635d6665da5ecbf5684ed6889b0dafa3bcd987df4e14e4291712dd0471d5c568ccf5d55ab194fb8bb9325b84281393ada261dc4463b7018a7fe5457c70522579a4dad1909ce2652e47e1fc2361e520435d579527a52a0b4ac90a899d9bc0c80a5644603cac8a373569635bc91938c217b2383da75bd5471b12d7965ec2bc5fd657a176540c9cf3cc458fb1e2131033901b80525ca4c4eaf8e5bf7b0c1f9b36f8d404e96352effd594cebc97b4ade1e981acfd1b1a10f6c44bfdd6255de21f0464394ecbd6a59cc2322770676449b77aa7f28257398d0ff906f0f75bc92cd955ce243005d444875feba4414b26f944c5bf9e82883d061477edf5f69d37ffa46a221ed76a83c2948e0cf9ac2817d3c07f5d23ebf1cdfe4b1207d57c24fc5e24619a307a4424f23d22c6a8d002c48a80eb7fc288337a01aa728099d90f128205f0bf7cc750ff07e8739ffbcea736cee976422f0ef0b5f63f83f761e025b0d86c73fc794b05b67b99dfecff50f9525f2135125de60a5997babdfef8c8dc675c22f7239937f6b62daf3729b8faa9a1c5d994e810f70ae0ff3c672ec25f6ecff9a854be18ee599e07aa3174abbf2c6804fca95d25fa778ac0e3526c43648498b321c7204e19d0530ceab4b00d72f6d5027cdef46555f9581776dd3d5c7795a1ec05ac94406c1677c6f6f832a28067d146db4d8eec14a6c3e9cf21d0128a78e86cdfa96aa5354db891c40dd90b44a9e62ce555c8b9d4f880ff445f71ea21633a3997d23f73a8724ff1586418e233bca01e501618bacefe9126d0d81ff25026b8a024d4803cabcf4d60d0747ff9af4067c7ffc1d05ba8a7fc40710dfd6d5b8242faa222afc551f40931873c39803887a8b276257abe92f017aafadec009e4f4e863b19c359a7a89e266720d6cc878ddadc615030dcacedeb2b78e7ad88e1ce01bdde9ee9faada1aaf802bf14c757dd1083775ae08ad23bf86e239177ba706fbae75afb664c53999676e15de624bf891a3ed7ec075e245c93051a9ff8118d1d9e140afe333a817d5429980d998b3e549fe0b5241f50a98cc22b1d27ac3ffdf8ac6e2d5751ff9c6da8eb5903e02c69db5f06f79eb9ec35b6d23fadbe417d71fe9cdeaa748883d54dacf076681ebef5a2d0ac796e02923bb21aec3f72ffbf1d5ba9d8336e721e8556f69031d660b32df6977bdb698cb919f8c67421e4647919910f3257e9fbb84261a524bbcfe860b4ec9a4f172935c4526118f78d112edea2e25f17987c21042e73b06bffb94857818946a9a2926d98579668048e68a8a1524c24d848ccf518b19a62035af4ed5a823537d1237e2447e47c7f28f24","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
