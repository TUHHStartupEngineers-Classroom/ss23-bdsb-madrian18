<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"d2142d0a1a35242f178f43ba3f440f533bcfdf5e303313aa4ef4952d4d3952e73b377aeae77c3c9eeeb1e5714a463285026a2beee816221c6209e0479ecd8fd8b4b59cb4aff374bce953e3c3f9719d762acc8598847ed37ad7a65f3707fb59c0c0d0cd12b02e8ccd1b8405e12ff1db55bf62adbe0035a2e5746a87496203993389aa8999ea431fae1fade6523b93d4c26247d0bea4f6c3c00d7459125de92ffee0ee9f434d2488ed649ff839a728684fa1d78095309cb71668edede555a5177b6089407201dab72f5083a046233d8bcebee52511a5faf661daaca34a869ef4d175a7e5b364ef0614fd0c6f5debe3fd5153f622ffcca8c0826ea9272260ce6540dcf7c63c731fb8aa05dbba702f8b8d550228374332ca956b560b9cf663a7eb127425010afc5f1b24cdf6ea692c0a2e327860c72c21e6d57b1c4d9992e379c2601a766be96e9996bc915f4f42b2bca96bd44447bf98e5c64ca79fe6064a0a17ca34aa0cf4779730d3ba1f5e7e9f91a8d72b0d18e1cdc1876428040e29c224c3231e12c6e444a49f79d06935aaaafa6eeaa88ee412fb4a2a64cc7167cff3fa929b59ce1e54f13fee295f9775adf9736456a23825aa6e10b2fa32ee8659b60935346654bd0a5fb8b15dc070cb0913f3a00fc5358baa19caa42bcd4e43200be6966caf4a1c91fa3b7c744be33ce4b2c023236148e9bb5106387f05c314732f415a70565ef5311896797ce91450e3886f590c0a371df7827cc41b97ab73e66cfdd2c28da9da2a71cf45a27c8dcedbcddabcc9f732ce697294cea2158e5c77865fe4b06efe462a0a422db8bc54bd015aa7ae08aeaf594181e5d28833fb1e01002ff32d3e515d7a02eafa43ba55434147f3efbd427274a952546ac4f91461228380bb7516ad00611496740a68d8215e16f3146fc767d2b61060800f0dcd82fdb45c4765b6db115247a2c7318711e3a0331a6021191a359129f0e0498433d4c56344475c8bd08948d5b0fb0f337bdb7856d4fcd1f900530f76ce8dba972fbb511655043373d9e1a43b75ae3072592bacf82c2660e002e408f366fc569cc1a5eefb4840252b090682bb2919c50be4ddf13526ff86608187a20775663864f54cc394bdf838cb268b3af529aacbb525fb3d83ca82ad96cbf487bf01728747a1297aeb83fed9518b2de4621d6055111dd07406043f506b6aab4444ae325a7fc17ee7a7b82190ddbdf2212c7ff0d6d92e96edf66d7aacadb89cbf854202dd0e6e45ffa84966be8ca87e45ed5d65cc72a0846161e3624756dc13feb7abab4f5d32ec536349c0a382a424ac9aaa378ef815807bb9a497d2f4887f0147c9d3682c11036324ee7cc6de0b2862f692ae96f170872b4367f773d7cfe3b2a477b70363e99646bc36a237e69beb20e422d356bf16590ba93102a9f5d78a242fd16f489d060e6c60a1d2eb12fdaa931d2cc5dbc7582051eada1ddc377480d4e7028a96e8cafc8d1de00e3765b58dce6d7d80464e3160e355197a9e20542d6b631e6f6a1d24d47121e9e7fec129f0381fa41bc016bfee82e17ac3bf1caabcd8c7a80789ab041d3b8301ad855cf3ca382b8eee74f9400b9f3c510371b8c89a3da8c4cb8c3f8c4efa38782423f235f2085f5c52f99645f1e9fd6cf17192194436325a907751f54bb93ec2d04a464f00ab51737e1344fb5740dce3d7f13c6506280e1b04037ba1d395572abbab30e37cf0b392507d8fc42a99dab0ef552ad9ff9b9c9a5317ae3597a513bf4a953d819d00061fa621d2bea525707f9b2b2c2f2eb5c8350ecd3c6f5a1da78c2ff4a0accfb2c75b6f4f28298cae937e17530ef34ac32f5ccd03ad2c16a05940985426715c64ab4696b96fd82975aae94c6adb08b96cd5597c08548b521ceb231afa2f006c29f8c1a5c54b48c0ba2e1a46a05b4c302dd3aba9089cb4a000ed8acb4305be2fb1ad83b006f95cf5ce24ea0121afb9f9d156b5149533f3d77cde2db575ad595e35b8c4f9599543ae35537c8deb0aefb6ede787dab62500a982ac90f759ed374187687cf24dcd22f26bc256817be91a09ed3acab98ece85060aeffd7029e748a1242912c02a6f019408d41dada24f53a254357732deef1e226f121b7e98c9eb10dab0f4bed8b0f52d9a9803763c5f4f9a2dd028e2de10fe1ef93623765a227b66e48ca434b22054e2ffc62dfaec2e3342f7cfd2073a9ad733da16010317d681173f4c5bd610a98257ecc8da5d26e42d79e26855e0e7131ac9308159c32f5d0e9ecadc31313640c3d740fdeebdce76b0284ae40fc081f4985d2d779463ff72f85daad3c3daad71e7a681d3a1f9854167bc823a82422752ced774610e45f0f2057cd48cf92db9a70d464a4b49db87825fa355ace5f84a76ca2dee9c2c33d7d17d8716d43382f9b9ae56323150439c4cc58b16b1c31c13509d8d153bd58c0ff03d58f97d06f9f00bad0d109a95999103f0b031253c2348a548e887e5e5939fd80ed3c73616d55cb8e9e6c6eb316f2375935835955efa99c0708055c63bd0248f6ad1fc7e394bdb2d28ec84bef55c13cac62530bb697abe2e489bdcd89fb9c9717d856c6f377ed8ace6c72552f56ea2daa6057e12227fe72d94d2ce3736a272cc8777b9a62c182a49610d718e13b07d4bc10a97ed40e4bfbc8b318406d34a043eee98bd2c7c6cdf19d0fff7261f260f3c1d3dfc31b266e14b189baa8199d468ed796b18b63b3bc2a87769f49508a034e2fe582c3066d6bb0b01a0a6b286aaa301a7815868f40635c89ed95d8f9520058c54b70505152d41106b7e1ad4e9ae04d2f61c56bfb91007a4d3155621015b95a20b9beec2ca05f69fd2fe9a7c6dda679aabb5ee028aad7efa2fe81c758e0765ab911632395da448381c8751401e89c5deec809246ccff63cf2a67f5d77bf13c93c74d12e52afc8bd7056d8687fce1bb76dba55bf6d0f87bcb4c89f22cfa4e8f1a76643a2f23d6948196dab24f24533705dfb78d8d8ae891983ce11c912b3f6c85a02eb104ba9264f2258976f34050d09e54a80e05ac49c374df8b56f2bfe40935c4dbe99426295d275f505710af205442d360d2a4ea857a6e16148cd604c379ffcac91dcce40b6c700ea279a75443ed086cc77abb1882a8fba7ccf669c6992750f47c8813afa255e8478e6a3c64a81369c6570ad8c19269a31f7beea555975604b869e74b60e9398086dde96eac831adb800becbf374de23c736dd2aa8e692b230c70892f9b428e9c3681f2bccd7acd1ff164d0574321588578411ae0bdb3fc1df012385fa7bc96312b6ae7e807ebfc6e3666e655c7f8ac904722487e818babfcb75577461622de2172677d963e0b66c835fa146d95b86468609a3625cb3149b329f0997f6cc6b038ea2219e23c69611152c1a97911e474008693865860afd32c895e825b870a59ea449a29a7516e28e150b7d345a631248c6e09e23c9b2b40930ae05acac091c8cc369232254f606c5fb530172e25bc3098703f1f52a0b01b713b24506e819157e5ba0576b4487be6b9e9150102386c12db71b697c93bd343917d977517866d590e188eeb27abab88e13616bc8e7c80e0c2fd152c58be78bc3bdf955b8baa6206819be2fb6158112ae29c53828415a7547a7d85efa42cec27a6f070acf3bd62426d55808aca04c8ed91dc9453e56b4f78c9206eed18c9436e3c51640dcc42ab3834990e2e38734ed3c544bb178f86d73bd9287fcc3d0994a90c164f32568b53cd7377c7bb67bbc2fa5be0385e811bdbf0ad2ec3a9ae5c506ad9ba7177ef4cac721fd7acd46d3a65fb264005dbb1540706134704057777df7a2a64a6a8c51b12f3a4807ecc2650c8e8eefac4bd7b1e950d5815d72f15a565999ab0ce22a21dbc914b4786a6bd22077da45bd08f0bdd244596b4522e65fda16aadd2ea9eb92fe14a771afa32a1c028d5917d19a82ad57996068812f9e222788b7a926d0ec5cf94ce3aea688b16260e5b546dbd3bdc001bc7eb965519cfe1615919644331d99022443fff81ceddcc9d105fac86412b06b1a4c52e6b61e82ffb0d723640390970ea8e0fd672c138b889312d20b09b46ab9c789f48116519b4576844809466fdd09ee86fe4e2e0d8ec85cfc9f6b3739582866a2636e8f82cea5a9bcdef75535c090e3bd7aec617057673d55d589043a25456342553c408c631a1b978ee67bec2dabe065e21a96d140b576205fe86e1d62badd6111ab50f8dd45f2206b43d84bc25ed2c056256cc3781944c63015da6b50cb9c83ba3104ba0d38c3effb36881cbd73c074c7c3a7fed055d5baf31db5f2b36105fe98e075d724503b8294372188764bc09b06b6a6f6b784dcf1f2de553fa1083311c6b87b9a57ab5b5e398e77cc5a0d9a03d70ccf50b59044c584e1839a9d132dfdc80d991064709492b0ac7f1527b2f4805337f67effe479b4bb3a1d21a16254d3184deaed6379c8e106c015f1788eafcf89ab9569c3ecc31f424e2d640d2cb08ad24b614f8a8d24c6bf9244b8cbb8c4934ae07ead4794e5fd988195110b1fac212b7a5ffe983a79648c44071420bdf8e567a8100b03b608bbdf75c44016f6e1a615b3d47d997328b7798738158cfef6b8fe2e9fcbac4882154411f90d61bc51065cee063970160b3593f779f9ca29d38535298c6503ab89fbd4b68d70b239268133689827c72fcf72ad33627551fd9f7f055587036dae03af27d0d4534af7f81b499f4a7445443cd6a79dd339dd52be894dd162e4dcebd278fb832ac3f9fef4d5c2b432c72681cd0d2344ec5c3ef41cb0c5c2d0cae2da8a947d6e62880f3a26da32e5e4d15c2abd0f7e64241dc905fdb862eb63107f3b360e5b5fae5169ee24d27e1068fb5cad3a21700fb38b97d990e3b8f191865675395d3413c7b85ab9425328ca40228b8fb1d50977073dcf27b229a262d4a694986adbc19ec7da2dd2a165454beed0d969440a6c0a7cc47adf3605d78336b5eb8df9a47c7473849b6716753fc7db863e3d4edb7053989ace3bba5201efec354c1e61b6c7e96b97cafba491ed4add2c4024d5a0a389c6f5e53b96876c17fefe3767eecbdafa75397249aa9351752d459ab2355be72aa7b2f0245de141818b84e1259db5d8e5834dbbb7ee4327f9c6da851bfb444d386f6b75cff5d1bd50f09a8560a6689e599c8ef7920c9ffb5f5c4491bfc40e20c769fdd7c83b1284ba081a0fd40b9782e5fc31f04f85791d670ea2e42f48b7629b21c4bcff45b169bb462476eaaf1e364f939f32b7f281351eeb0a3d34bf266149a6e369b753867b74361e43d39937618d1b7893d8cfda97e11cf57e1600612eced38acb6c3ea834772be9cd979176260d92342223aa1ae80766828cb8941f755e7052ea843bf3ca981b23a6fae6b7cd85bf7fdcdd581150d267598c40c41bbb98be1346252f22b5da234628d35f1b939e7cf1500ac24686826e4ba090085c14fe2c93f0001a168ade931225878be3541bcccaf67281d74fba1f11f32c60d1fdacce17fa5cd8bb477dfe4c7af07645b8c810e830db5e0c17c34db158653b17b3d7db4ba38d9a0335a2d025c2b14e41d28e639e10410580127ed51b97f822e94d3c468cba11f91dfed4c3943e53cd738f2a882e856b65ec1c8c2b8e05f6bf88b6cc24968bcb525b10f296d060e25bfd7f92e97c208998440d81b66438d2586c1d3b6efe3d2e404a52af4934cd7dbdefd4be2095bd6412fd26b576ddd9e6cb0e4305ff5dafcdaec2efdebc45c0323ec8cb29e8ce832f81720e2f1bd120673c1df563ab5b66daca43a688fe3d9b6ec8f4ea6aa9079c38bbce9a85b60eaeda07f8d40a3e5eef43cd960d62e26dfc360e6bcb9f901a1c657a05092ea6d596c26cc4680e680111c8661638911bc9f05bf4ab831b24c9dbb5de6bd4d022a7a8be043b3163fa73c283ac17325378babed4171d70396a9e816952e1cc4f01e3bd97ccb8becfe812a116246b6ed4d44d4a55232568d2851df75893895a51676481b51c6889ae54cda6248220bac67f209d45ebf3ca64e35c6edb12b1e143532c46c2307743ff5914c6dae09b9751ebf749bf5b941d42380e0ff81053aa6e97539ecfa1b3b39374c766f80e8b5698b35eacb1abd9bd7a1b7cbf092d09c3330a61c08729a7aa38ed736ad4e3364a77c4768aebc16c951e721962ef18d4384f37291c3b0854b487f65338aa97799a23e219dcdca944c217540dc326d5c708969984d07158e7216303eca45a3b4747c9fcee41ea50ea7c1ac81520b13db10111badcbfe1f826eafea8dea7836c3cb586a11bdc045c3b0c068a1b59cc56c800871fc624ea53e03beed34e05f8cbaecd0cd66b18e2347317c069379aab80f826bf558baac3b6a284208215e595613874ebdc342fb55ee8bc9ad85929b3febfd94cb8905dadfed13851b4c4995470e9f7f8a0a25b725059424e88f984b7db069908db6fcf559ec2ff25b63fc8d7cfb2cc956b1cc081aa064898d89d3de92fae64f944f4c20225fe84c04cf70dfc94205a14282324a98ce5e354dbded7300dc18541df8b9b6ff6a3120ef1d56565c4b95becea324ffc19f34ecd2629dda15f656c742466be7afdfa7f8d68e7a54b2c4431b4f6fe9065987aacf64380643221267c31d91c5bd7559d55091225ba557c7cd188bf32a29aef78b84785597333265323dbd87d15e5390074d72d6956c14c63b4dc138b7859ecd273deac35afd3120e636983b07e7091e206595e0356173d0d2aa1a1cc7f77b55f8c0648622e5933ccfd400143e659580ca6e240a3ef6e75d3b74bdfe5f3363cb8ecdc8d63a9ce2a2c1c463cc0728229a0825ae5d497199e97db5db43d3374d7a665e874cf2feb836704b21847a9b7f8b85785488f21f83269cff86affb91bf85328cab708f7398c525000ee6dd40236413a9007555fe9f050840fe793c548b0e21f7df2e2f72671b38265fb167d74647f3bb090b3f883132adc7bfbf4717a70718e9d1093eb1bd4acf8d982196ba0d63234778b2f773f68f7c9056e9484e87bca0bcef6a1852b237816edba1006683b29d9697c7b4b5de49239b409d99708856a78f832c437a506ffe6711341e9fe71352462fdf5989ab3da4d995ecbbb645f5db5a778426574f2d322867bf344ab3e78b89601c618bf36f42320ddc4a47c1de970f6e4e662b44042ff2c6563d3d1334d96dc8b43b75b31d6eb4116cd97b03fdd6d9d8b39593900e59171bd7f4fe0874b9de6f05cf6cec8d031ea55562739465cda7a00c6c8bad290c21494a880abde56a1ffce5d8f02f0e2a8836d542d3901366d9f0143c385181f68df904cfc74009e9ef3477e988d8a22055e176dca3f37719831a987661793bf35b16ef20124a84d88caa86c0ada3594a54dbb852adc1f956ed3da03105f8515ac7f26f73d66e3b47e544171d21a394a7817961af350df8ed98b832e4135d0f714b7caa348e83568b8094bcf8ad96cbadddc41c24a8162b3fbff4c2f03d1deffdbabd00882dcbf5cd6b97fd207418c5e795de15a21920a2a1c11be065c52be89be610ceae39e3d6db2f2c0314ea082438a41caf7e7275e31e04b8203d89b378545d1f30f0d8188b15ece3aa550e232a5d593ddea6e9b91a4496f8e7e648fee699c6561f0d85eb15e4370a10e5ad4330c808915770a63f0b4a9b72fc6fe5059e455f6cfa0dd1682f1eeba94735739cb36069e4d42cf58d55e5506d0e3cd3fabbd9ae2a151a47c2731467dde34b64c9e1c937d6a5e5fe2c63f4df6e9ae4c338cb6e8f7f085ff2916fd9039377547762537a7c055230344ff0962844d9fb21f23cb2b3de4d76479c124e5cb7ec790f632855ed960990568be5312516b5ffa956f936ca833f327ba94b760ea2634454226716626decbf2b6003415d32ebabca9b05dada56d4536e58393e08a9e77e294f393f383105ce164713b0baf7e8f062cbb9bdb0974ecbc0a3fddf6eac1417b46bd1adfba48f6ed468f4a8a87643d5e054a88784923479b1d2aa5f3a3d50c73ea1dadc59e10279f099af388e3d24ad8439f95a006ba2b774dec5e6b0c4bc3772950116ad4b46ac093a52ce5042845c33b668f6ffc093586b044b4cf87932f84c75430af6a43fc5d2f37daf653e32adb1ebcf5711740fc771b5b4e09871646d3723d6f8a98f6417e505fe3619bc39380cf7a288e6d08846c7470aec627acf80090d0fdf17199246e6b5ade09eab7244340a48def792ee2ed080a6d870beb41e82971ae8c10df2e2e9f8908a51422f3d1b1dce028308c1ab45b578576f3f9f80919112abb2548d40568ecf9fef7d1cd0310ac2571b78fe901c057814534a89dd5ff97428bf195b6d5b2972ca84ddbcba7bd21b131bd922b5fb00445d7034caffa2931e44b2e56741634cff80ce5dda116a41116759f5602e84f755ad721401ddef28974b114d702125fdc29eef0ce869d11b6bac4a6589f61b842cc99666897923047ebc0a1ee416b359adb842542e46f680a15dd8fcb72dc3685ff157ae814978d77260f454862769d20e1835c5359500a56aa56c26bcdef5df1d4baaa1af29f8ca23efe6f4371be9cda87faee7492bb00504e1a1430edd9658763480c6369ba90fb86abcf9a77e4c1ae0d0f3292a3d9b927fd2e26b20169a400f3c575fa889bb928961d847b5b42af7a87687b271486c9b5135541b412db96eaa0848fba4832511d3742e70028dcdaee4ea99ee89282bfcbfeb4047f9b373804290c8423fed133b4c7ec31fc7bcaeca0bd4429e2d60cc02dcf45cc355e3eeaa8db5314a0e7b5364be725d1f25170c31f08bb04fd95cb33beba3bd5ef567e26b0862bee97a9f0298476dd8ec42fcc3298c445b5a4b5156db6e544445397b3a5bb33d3421be5f1f0e6566ceebcac184ec29ed2b3aafd84df25ac570969cfbb06f9fce06cd23e738c8e1538d305805dbc110ff141cd8cc181db32a2335e85e74cfb81f208904a0d8a01296252924e86d19dfdac8f92c31331bcd3e46f8f1529046dc906fb5b643b690ffffe70d8be78dd05d6e7e6b714152802e84fa39c368ecaca93691b6a0040febe29d80443431d60362cb3401c8eefc9f688d587e593f9d0f757345677edda68eddf3fb7346c4b6ddea7aaca139d721c470fc88bd1d2230bdb6a7773068c30e30a9e4b3ea2046e785d6a01b93380e4050e9379c4ae4f1abcc8aea7acd5456b748cd467916f1a338c7e544ec24864d380505b93c15042bd1d7794e41dafeb680fd0dca11f45d778147d32962302f09e9b3b61602101412895fbc03ff04e9a10f814d154a909d866c817774eb7af38cc743ad09bee5041d1d602cadaf288e475f4e32281a8808f7957bdb9228b7a27f04d73d11a2fce30cd882c3eea5cb6db8157968d8969cbdd6b2864bb46fda384fcda9bb9ff6caf6da1c3ebda973c284a6440a1e85176145c616cda806ce4399ba737aa1a9973c85f68cfb3a631402123374d2746d9f44b92cdab616b2d5765cd672a108943e4c83af9eef939ba1a6be197f4a3c5e26161c28827f62e825dbb7725d4e2c8083f5d4021417c77db8ceefc91b659ad41e1270982d308c2ed34666a6b93fc1233d8d636fdfefacfd73b1c01d60894780d274061863df31510fef522bd4662d7c29ef6975fa3831c004d4af48da4aa0e5e319c38e38e62d9fbd37ade358376e3f9a9cecf464c186b552684e4ac29418468310c84497f9afd1a9e8b9e57de030c77076a162c3da2cfc7a51252eb5a64f8d9219347e852bc6af6d0f0d7fd91cbb4b9f23e7d7041c11e28e60a943c5564bef69b19dd920abb0cc640b9f31aee1425176c44c822a1f963df6db337f2617815472cdc227f1dac520cca264f6867fa719781fcc81c6d8156bf91b204252326b44e1539518902cfecde91c0217ee65ae7cfd0f2872eb10a7097d9d971c50f43cd2a95e5e2c9621749175208db6c279653df8d8ccf4c48c15bb7c67c67cf98659d5e618cdce436b63dd7a49fcb5e1e3b02a66a1ae53d7c64e47a642b6763e6dcc133f66f598c2b8d878f884ed6ef179cc0dc3f49037bf9d702ecaa02f3ed7ca6c2db931e42977f4efc4dc156dcd17e424d5edb9da7d189f97f155c2b6a2ff68339df6b5c8af6007f724a048be86c6fa7831ea5fe2518a1ee6d435c164e24bb05eaa079bda4fdde3f4304a37be5231e28f0bd8589e4907691602f8d7ad3b331a733e1a471bf0a3a2b6c77ad720ec3fbac27c16167910d5ae73374f36f9e51cb6322dbc47c681ece5127bd2258f9aa4ad69c5867edb0f5ced27f4c55c2f50f4eb0253068901f7d2b6ace0a19f15669ffe8efe81f01495c5d6f8b80e2fcc810ab9515107759658b6029c2989c7b3f5f5bf9a3e68ee46738789c5dc2705451d3d5eb7f45c7b0679a9d107bdb855bafcfce48705032a0b21df7b0738895494210f48f9241aac931271c36bcfbc510c21a48802356b1347a356819e44fbeab52a0389630e408e396d97ff855305c17aab237a67c830d4b1e26a4fb330cb5a3895ac0111b616d7b2aececf876d025bce1924d1fc9a9f36df5d98def45e5eb607ed33ce95daad402d10e059bfcccd584ce043019aed2bc210916ef2540953d9a9d4d7512bd1cb94f088019de1a26355963c314d80de8de4ca95b9bab9a93413f9149cb820584420966fd2c526e59389ea2143420e201db7272687e823bc1cdf47bd9a8e2200f074c62ff5de896e896c80e12b7b1ae0f3969f74bfcc03e2e35b2d4ebba14c1329525816fb6bc30a8d7c43c7f7b48e56f5421b829d20090f808cb92cbbc8c7f49e44befa5fe293d9365101b991b367cc21a86dad3ebdabaecf59c2907d762495254a59908892050e828c39affdaef5215d098603e1d733e51249a99651b036658f3d80c12ea67093d7b7149e362af431edb8cfe213a84c4302fdb79c1d408782e85f66e0be23e4ef2e8bef5a1e8dcd5ea1f1717e3cac83d9f5880469d095614c9fc3012c7a6fe75bf95ff3195314d7d477af53e61e9b4966cd1691825bf6b15f4f523a97dd4ae5172fe753227518ad253780f28237316a3949ace27f6071c91ce30c79c89486867176ad0122ceb05d9673b6f078bfff5af87f44e6511c7542480acc94ce5be74f368bb2fcdb07d0d266fd4d72983e5500388be5f211fadb95aef95d8beb3deb73671850720921f27d0bdd727fae73f7b7121c24d6af60b34e65b7fa4dffc9bb0150dd176cace8f4886b59e3713e24744ccbb882c7ecbaff6cb8f1cccd2e904cce10cda1b33f9d35c9ff5167351efbd2580e1f90bd5d2efe3350ac0e061490d1b998c4d0f2be9e8a196b6a5e2029f9c34db2d115dbfcb771f01ee90917c36dc1983b523c6b17179fae4bdd3983280939c5c9e655026cde54009abcb1fe877c4fa5fb4cb298ffa18f7896be9cae72817f635a0859fa15ec4b410c06868c56b84d1005bb0e12e9564c8ddecf030a6e9dac1543b43b32b78555c99453ea577ef4e5859bccbbfaebfecd2e250df15c51e8a152ff7ecd07b30f9d4a5445bf8e4163b0df110f072245a173446bce9030d45e0650adf9b5f3549323e10ff9bfaca4dea3f9f188d78761bd3ed69b7b58177a093c2f1001b359886a467208ef608d87d7d99b04576b9f0df09a6705f9c233a7d962b713ac38a206455e1f528dd5dc4038a7f62e7f0773a93910829a84875eb493f839cd2d3a57ba0b60d041041a24aa42d12c7e0b9d1fec2d9765e01d64ae274db6a425e35e35550894eb02cebe98ea7b09ccfa5c0a969851e0c348cc91205bc78beacaca15d3fa0ee4dfd5b9a411196a9f7f0f2f78734e80c26f84e669b3c9778e963fe04cc8d4ac853aee1e32de3f9eb3238ba9f58f55fa0cec542f6d815b2a51ce8dd2c6d91d752014f45beb7084528aaf1b3cb73e85e451f0a3f34980cb9fa7c9a581b8b52eddab2b793d5f419ac90e77235665d8e15d24a25c6d1d84dd75e70042ea602d817229e8a62b5334515844b8ff8a13b9009b6b50c1ae55bb768957aae7700f03f0acc7f7bfb1d92ca398bd0e13247e2cb898348752dc254b59127ab5cc257212f07149129100ed8d01eeaf2f748ef112265faf00e5b31326e8b9955063fc4b9a74b4e35f618d3d1a75ba74a693e8d4841ab1e68cd7218d84105694d381625646ba7ab770ca4257084118c0901f1fd571433dfbe190f52d3d939e38fc06d84ec94f13a8b16cc5937658af005889fdc6757cba36a88b039774e2a36d0383aa2d0ad49ad87142f6b86803786e48eb68fddadfa94a888e81ea94f162d959909605cecbc97d21c02fed7fb5ce02d57da0a3b2f80d5f6d0b595c474e3ff1ac3d005f252df8c2c6493d198d4b6840c28fad757a273a17444a9ec0cc59b61fd94ef844c72e8542c7ee231fbf3083958938864936f3599117cbc29988dbc169c4fdfc00cbc925354e5ae12173d19ced9026cd3a00d973301ee4aea5b5e5a7c2d475f1e7c8b4b381a955ca18ec6e358d58fcb24a0c4bc535cd4c1fecb887582ca1b0261ac6622a549d7dc2cff25dd487f1e7766904b28b613e8bf10f8804400eaa4b0da2dcf27f2e212cfbb844c8e2da3ec7481776cac0f28a29c0554ba6a446fc9f583a020c501071ec99954310953f01d6bdd217d1ea5e290775366bf3bfdb118d2527ed0c96e0e107503647781f2cdb2a58dd2b7b9d4f34a79b5bb909519ac29e57b83e860a1f98702009a828cb8c055dcd41eb467b24dff916d6e73c5accb94634f8a9d82c5fab8f591e8afa9e12ffacab11ffd7918681d3e228d515f7cf686a265581bd02d6783012c53dc801451b7791f3105d7bd46ef5c5d19e69e849d80a485223e5975782cf98328b59e5b047388e2cf4e21a33004ede6d2c427a6280003a0b0e9b49c60d947983be4dc52d214639a35bcb37da1a1a0246b08e087b26f942cc33c9c1dcccbcc2a9225c66cf44f7613ef3ed8688e8cc958e8c5d35be515db9467d023532c7888af6e30bfefecee3f2d183a0a14918850de28d3cc9d2ebf916994842c3aebee7f9cd732c1be63e1aa39708dde330afff50d99e3aa6dd447148fccc6649624d1d78d3e65f22a9ce4e8bc98461ef46477161d27d1a2bc51c3ec06b9745169e664e3a14aa8bca15c41ca8f6161f2facbb25a547fd6ef422351b1284115f7f3df778ddfe52b17577d156d2c7bb27694231d333d650bb1c00b3d166cfe46f0896efbd66da7f691b6c61a3f8f6d02671e201db06a74970cc003acd9cccd55e003ffe881cc11bcad255d0385139b963bb28518b6931d8203c9ae4b98fd163b376b821d59748077fd1a8903fa9c9dfc3021c3200b4c23ac7700445e61783157e3266225f02f5e5099a71891d89d8201ce829653ebcd0509b673c342f218faf08aee357df71b2b14377276f47ec50410b0e87421981ca92e4bf7193be686a01fa1a0d2bf93c2f199b1423bc494ecf443ae7c2e755051b22d4fc0066cf26880083645ce1fa256b2bbbaeaae6c97c6f2a691291a4df8b867ed1c67b5e02e96252ee21828306c73c5581874c40f9de67c045fa5aac2028825a2638ddcf1486ac07fe30638d87f45277042b80f570e75bb9e836253eb081ae3f4da2fe93f48fb3450da8ae476ea091a432f8947bd12f2dfab735a63b5e3459e4d90e42210fc22484a371fce7ae8664de76c7dfa5215d2b5ce477f2ca02d64787ca8a8c18c9253b094e24edccf7d8833f19a6009dce3d7cb148d521ea383d1c211b284aaf2ef24cbc6dc9a0e94ba419174bc6c3cd6b1e48a6067b28b9b354f89a495d211b408ee646ff15a640ee484ce06003917a389178048b7fd3f62f1843c3a073514103b5a1e399ade20609603e16f52b84deb7a4452e51bc277fba21e4b5524d25b5779f2cb776da1482207b9ee175b8d89a015ba51562edde6d33772771d2ed6dadbfd4c064e8b01e3cab032fd9c4102c0e203cb2120bad094a55740eedb3abb79355170723d6599e5ecad4c6b6ed0f54ccba1ce5c3dd75e0e8d2e5d1d3ac6759617b2d4cda371d242680c7e8313d225137d9e04d62b0a640e9b94f4a2b310ae8f0958b9770d29c3b7874183e6f6fef1df29ba7dd162b21487ea8890530ffee1055424b8f1ad0ee32500a57f8d74812d374660a077c4b036a6e03d97b561440fd75a41be10ea25066a0f40a1fc3e3fca7299f81e9fc887daf5fb26d10b91a19afeb9575d06f85b481aa1a715d66c3df3024b5163c19854b2fbb4ac9e0d15c04d978da7a3235b16b4b3bb05ea14df7579da161a19a96931c642c718b5e90579bad81fd0cb50f7c0d555c21868e0924c23ebdf4dd31d0c97633a24549057dca3414217236aa8fc4f689e89cf6d3ab1b1fda17ab6a330528c38720bce40d8c35ea703b6fdbaca607adbd790e634aa74bcf4d683b99dc1b37dce545b9555b43376d21f382bf6d84f3aff5af3b2b1386141653cc248bfc0864ca059ea93b7f6884bd3e22a8f9685bd3dff90afa1c06cad4eef738063205ad4b569c1b6874a3ec852dd4d4c006310a160d34773107ae71fff88a26e5fd98803aed7289bb1ed77ea3a18266505e564c6376b9b9a011ee3f02fe08ebe2ae98dae14d6c4ce67688c115e2836e1e4109fb2e6460741d1ebd49b9b15fa55244248f11af80076ca654b12d4263e06dae17e49af177d4e36ad92e3624d072bc9908a12e036350cb9a903f6204b014e11d0449e4793c7d296904f69f9651bb33b43dfefbafbaf41044eb291e53f4c59d283087e7bb51ea7fc310912e4c2acc7ceee267f9849f2b5ca1f59c7d7abcc0aee4c786d007b4109ca039f199da6ab6a82b6986b5f6fb699de858b5b36a27cd36aa6b49fc9baab4c622f05b619523c58e3978395ad7454ed47fdcde12cd1d0d1ec4c7ec542f0ed91a174f090598e4b6bccf8d29d8bb1532c3b10673362bccb1e57ed09da830f99b02682d8085fb6c99832ee2027bcd5721b7dba3ddf4eda52469f655f41976374149dbb642d26e9b16c05f617bb04f731bde70576fb4ee2fc7f60e896c413c7fca10923b94f557e3fc45c43938ff8bb810545deec134d4f25cf3d2a6444839d13c2ae3c151713f01cb643f838ec98adb6a57f135620024be042cdc326c3d0071fbb0d3218493d05359f499399b0bc8d1de6006b71c3525ffc562544f3052f84c6a55a30e849eeabb1996913c5a37689024a2b18582a31fb7e91b6bbcefb2e50adb112596e04f871de18b4bc8101e2ee57fc4f2431f0803dc32aa82c43ec44ae6532caf7dd10075b449147355c9ab95138bd864a67e0c7971edc89f3d5af1a668c1cbf619976d9aae79e135844c314cdb3b8b1dac89934adda060a1ac15755629fb9e34a487701f0d0177c3dc444c07704bbd653bef620409c7ad579c75ca2e1768e674d277e9f5ec001c3b2f65f4bda103dfd41b7ad067ae0e44cc60c5c77a53b86673cddd60f3f467a6067291ce4acbbfc5df238674ecae3496363ea676e94d2f9cf8a5e9bbd143b3597dc5a8eefe4beaa60091f2e7efe8f8fe739cd03090fdef3cb66c21d8a50815d1b1e46646ffc4ede11ad62e5520c214ba0bc5604238662899376d2d075898b5d651e9f28b8f5f3b6d52d405f2e88a372e6b876790e1ef59d1ff98e7ccc30163a2501521653d13cb83471fc65e08fdbce90bcb96d89716ae2aef290105d2ad50cf1b543bedc498858c23ee9f97798b9efcc2bd452e9021a81178efe6d03abdd0faeb96317c28f2105855a3570f58ffe9776245a3a7b272e813d123017bf0842c27a57c8e6a43bdd636f39fa790a5519f736bf5f4f430e70442e8a4c1593a4ddc3bb1ae71fbfd7a6de3887b8c1848b34e94b98c02fd2d8a1741c4ffb5f9e485ee6c4a5afda96b83ed2c5a9ad33c1dbd6931737e580f1927c86993c5b7c83a5b05e642a46f68dd67f89a8939cc6141fce2493fb356a0cb40b79c1cc87de2b01961bca5022fd7bb81cc24fa071a20749c8e6a43611828cda448d1e5f84b98c40929fdd4c6cc26633cef0efb050271d88b19f41d1cec7ef3cc9c1b213f9bfdc5f3bad0c9990031233315bc67754277fee9c7e0a732a2da24d9c43644a70e64079bd016547b91ad341608f06661ef4c0c2496c21018015559cd91c02fc11f5d9c9bb6e68f1ebf55c189e264b312b7984c4860cc83dc9cca58cfd1ee10abcd854ad6ad8d64488da604008424eee2cff5dd3745e2842b3e20b21386718336d0d1e8d7e86e0611375890687c1fe4906bd6a9f6ac7fd3f6cd7994341f2ff039c70a690583356c6c44163477465efdc8ac72ef58089bd19e54b87580965b123c835aa3dec2294701b6e9942491346b3108cb14581bdb4584c28fe049bd4d94aa94bb50f5af9049f00ddc07679fe9357eddf8821ff2cb6efe962b3b3ef9d5bc041c0429cc940f82089f697755db349e858a1c10c6a4de78bb5a10e85f46af4e5bce3bfa3d4ed6835e97384fe322c5ae8f9157341c180c69c562bbaaf8fa8621bba0f93a6d642bbe1e4ecd3a036538f559479b760efcbd0c26835a949ec8783fb0c19df2779d3ef6b24df42d3d57cad587380254142bc8bec06826ac85e347c766c7b7b18b1e04f1aff84168c99bb4b7f7bf1ae5de1188a101696ec47cc7397c538771936a58f5ffb48990e12a333a342419843328e779bc822800e943c3ca5689eaf0778cf34d0d0a160fc1e5eb95f2f5cf2969b6232b8b384b7d18221813ea0572b4aa48206ebbb0f14d18816769aae19bdd5540ff6716093652c284b6a8c0f29621cf9ae2ef7a336239f1f81ac9127a4716de7087188935799bd1d061b43ec24ea28e73ac8bf81de888eb9672e3d15f241a59e25698e8a1476a2a413089b7c084702c5eb5181ff440297e7bb925ddf503708fc8bfe1f7be757df57650e16392f2f185e806ab00d2d655a319b1c7122c819f4a61119702829906c2796d1834a5e00718ccae2a3ba7de818df5a9a456c02b30a27a441673fc0ae333cf1f718135acb4ad783dc06e8cb22a5afd9728907c5bb561d429b8a52f67b325f2dcdfaa79a7ab3e4005bf6c1588f469234d642afbb95805fa59ce0199335ac09d3c2e37f5630e7b1c6c71b34702b4843718bd6a9e1721cdc4eb1474ef38bcac1707cd3d4c19505261423728deb5d1907674e8f3fb80baaa26a0a87686e794d40928cbeb6e02c8eaf5605701d7cfcd6653b281bcfdc23468c918b045e9b36a8cb57c31ab59ff50d8754d6a51de62f18334df42b8c4b38ca13eec14ea94683cd98719a1350374e9f29b5420e7bc9a9c9082e134659d687eca02f8946c0e960822ff8a8aa4a776baa6ffaf7093085e2ce7ffa1dd8849816a89a4b517784831e2c7ba2b027a3cc0dcbc91b79878e88dd707b690f5c74472646e92af331dd3985933ff8ef581c25a04b8c017f51a3e311a9496832671e06d93046d095f3fb092fa0219165be35870ab9c5bdf247682f1eb8a8a6d65f3802870619c1b07861f080d608bcb8d92dad06f5bdd4f9cb9489bebc5adf84697640d2085c517d1b2a7cf51b6f0dbcbd42f757f10ca32480d698aeed088e52840dff806d258d09558b080f14dd476cab98448394f36b983b0c4b684c5b4740cc5c16dc4bd216d1ed0932f50ee0c88f2075a59f1c1af9e996a52ff48718ec460a1614f776101b12b3e3ebd9259a2b7b0bf2a34be45d68b2c1d8ce2196e3aa4a62bf1ba85c1d78d57e843804fb89e11bca55258871bbc48248baf11fd83661d349e4d0dd3f1c99d98cb935bbcdca787086a93f2d9c72320c86618e8030838720dbd492d64beca44bec25989e2480caea060ce71926734d7ecdcfc32e1c3a9807a174d73ac1a3770d9d24458c7e59ef7e849bdfa99e333d80e242dc3f104343963481f28e4f036f2a02eb545393372760a9f93b793c826e7a361cc780a82bdf51726df37f3b2963c0bf197f6b773b3574255eca2447d5cde9d256b214fac5933728407551e1a231b55be52ff1c3189679fe0f0c2bbdbff8dd139ad446d578457f6c3cc9f7865f0bb0bb6a3d9b2e2440f73f347c07fc0f4e9216df9250cb913899bff634cf9b39af6840f8bc7dce9faac2be5e7936764afe9336a435c6e69ebeb7722867006858fb6fcc3039779c60e509821b042ed9bd284f4dad57298ab4aa3abc50c6d92ad8ceac96e41bcb0df9942856f2dd77466c0526b51181c857c9155ffdaa03ea76dbb8f4f55cc182fb6280e529a6c42fb635f15eed92e020824ff8b155ba953659b6b24a06116e2817c88455da135f1d99c6f15b0e54194664f9381ac5d5069b4a3a4cf3846d1dfdbb5570be2881ce1c2465032c7eb55c9688b983fdb2057ea01eba758e215186ee878db20f123b4299af695ce6855af78d762a5c4a747bdc11e38be8a98cb24d657173a5b5595dee4f614be8f771181777cd1411a8ea1a48143c97151547dbb3d93df2b55ff4cae09515dd29c807eee1e93817f177dcd7641c3336e27b13093937a332b60182dc83150df4eae835dafa4c5fd8091a3e3514cb9c8792f1e594a5bee25964cb1586d94a85f78132535d8144c082ee245ad705e841657421276da34b96ca122ed9b6c843d464104f968f72721162251853e172419279316e442ea823a95c4feee960d780ea7eac767ce6aeb8ba29da9cd514cf2785cbc7ff66e35a83109ce835801a6f5b08a4d9f8b0c3342b75dd50754ab5c8a667ea7452d5017b1b132aaad1d082a1d2b1c4d16c6e7b8ea5cb19a697790e199f2eb9416b895964420d852a7b2b11e9ac67739750517500a8c3cd83f675c4b4cdb6aac7d56bf8b4209315d60469351919b6620294dc9e2232bc67eaa34150694e518386de7533482c52dda272441292d3bed74441124390771a33d186a7797df4219eedc0ab1eee52ec3078d31668e51972ca768dd51d3b99af64563864ac892ba9be0bd7efc0741525b60f6aa7181254df6693c14e831336762ffb1dfae056fd48adbdb6b30d4e54c31993faf11c5d309b44cbf60497fb7d991cb72edac875e3b0f27bb53330eaad81d1bee6f6d3fe257b50f815f2b117820e001de197b172948c3a5a2cd5b02dcbf865ed68fe849356e54b3efd7ac55e3e2071b2a5b2553bada948ea32d4e5dd1f68bbaadea7b9b16e4cecf709fe6457f4c500e7bbea0d39c93149937573baed1aefe953faf818406f5c645849a894ef8bb758bf51df23762682e680ebbdd5471601aa223bfcf2b734311c336be58dc040800c75f3ca12439855268aba02562a8f56556b63a973d5cc129a14ca039cb6668be2448092a4c96e9d27b730ce54943a4e50259cdd04d6fe3023c9ad0240df1272314648516e217c9357284a0abc68e41b48f5f92bf16d40b9ba60c2310ee28872aa3ddf2f2b1b1d97506601e162f13fd15a6d0917299fbaea6f1e71afb8954bcc89aff50b7d169e779842ecc1db4e10dde1de673f83433b48cce6c8a2ce56b2aa5eb724ef5f7f9f923ec0f7b622188e9cf0167092fe16933fb9586c18dcb31c0f9b22cfae7cf6f0c573ecd8f9b1ed5520bf6680c9bf3a78b3718a456acfbd5df74fb5b4ab0e96bc69b0d58d4f297553e47021a03a4fa3b971d4d93628493f2061a5128a3cd459d749d1f910c9ad8368ed609bce3f76113260ca14ac1e9ead92faea48ee3b2d0973cad775c3533735fadc3d01f6ead572f9ed643d2e114b206435a4aa5f9a1bf6c51869037bbb58c6fde14386cd90d5326e30030770b97fce994995c1e6b002f83d2ebdec1559fab41a78fa4fb359e9d65372348845e54c15822eecdd5ef594277078954f88ffb2f0b32064111043a0bdb93777281e8c30a6dac64ec5ee3bebd893e82ae2ab9a317245a1c5dc4ad05d1db5d6faa0191f03be6df4d058168f3ec7d1cc5b49dd9a44d736564be1d61a8ac606ce68ec35638f69c3dab268b26e15b71260da0a5dcd4289f2d044c3c6520d6d4c8d445ed79e5be120d5c775241faf5071005a124cc3e9ff9c55243b95456a51ca909c8af7f73711783de96010a2dcb040650a1c3d65affc513d93ea3a7a3b8ae1f722574c1f83372125bf325c15bf791396199d1b626215ac4c4368c3531bc18bfcf86570b9dc8d0409826f1f98c89c7eaf32bd90d7be58f119d38e0bc0f887c22bb06c4e0bb8ea2e24f842c01f2a20b13b43885ba4c605414ff919eabfc8772f7f79265ef0eeb9fdecd662088593119692edc85ea700c369bf1be62e96a2bfce04128474658c7d7df62eaba8606ca0b7d66395820a72a381da1ee31a22e36e8e0388ee70b6524c7230352a74d143e7a9339b7571c68234517f6c341fcb0fe1dea98f397f68f77e6f4ec0d1b609e9d98c1c1b27d7591ff8a6f34f2c4c96d99b92c74d75d77637d6472c291542b70a827eb9455490ac22e47305f0870a3af7483b6d4eda6757e55141a846f579cd496dc2eb81910485655a7514365b242b4eba406fbcb9ff4bb65be219aeadcc8eaea021175821e30421c5d26c526ec148a1916b8952a14cdd1a21074d740a5f192f00ccf99861b6ed65db55436f1c8b26b100afe545537ae82a4d7d7e3dde754b836e821c7eceaa22fac0d74bf7bfa0bc12d741327f34c2a45bf038816a66bc9d0ecf149e0dfeeefd7c8430c4ec6070adc3d6ebedb1d550d6060527492fa0feb8d6cb899078a0f58d9088d444feeebfbf855e906a93c5f1cec9436a128b1a761fa01b34672e6745eb30bc6c6f4b68bb23b4ee295d67e9a75ca5793b825801ef3283bd5f692233a7795a72c27a8d1191c10bdb6c080a0a95a6c71fa73ff623db8831a2cc89b1926b282a4c3a30268ddca3ffd4ba3cf019eff588624be09a5b2c143d8e55b0192e512c0ecc53bcf51f15d928751aec53a9c0c40ae32d0f22bf656d314d43fd156af6bc29a380dbe2a7f23a04ecc1090fd58cdb4c5e36878cb57444eeaa1ff2021b6c71f80a56bb7904ff323fbb782fa7c062b85f70e5ed3173537748a0f835df72dc84c6db1ae04c0e47cfc7e6c5c523458ce1a1f97f434d3b2ef53cefdc0dc846e461e18f46a4d55c24599f7b39afd0695c66a4ebbc75cf4feef7c056cdc4701b6cb6d5753e016ada3f63aefec407828a2a6c8520df317dc6c4d05a2670253a9a610c461a5eeac5f8986cf64543c4fa9e935fba7ce132d9337a8cadc62196f539b4ae645fe86f45695e8486faa01e2915144606b748e2cd32fa9e9abf9ab27c1c6572b4ee7ebac0c32c40592ae0a664fd251f2762e29ebae9b721bc61bbce5292499137a177be92b52ac701e158f496e682fe82403c6fbce428dcb4bc6d126d2144f93ddc4bd03c5174915da0b01ca7c03414c34f7fcca562a779b4bd7940b04e76aeab0c5afdd0484203ec50cf612e47014c77676d0d438185d02a3cd49032ef29622fdb05cd17cca0a20fcc7701a25447bf6d5e29a54b223985f0dbce0a529e6893a633449e3e2dac1912dc9be86076730a573370e1ee0331b2727b9b5a90fa10fb3d39fd6151f357f2b89c4f8b37a1ee90686fb7d9d94a00a359ed5cedad3446c022298d2b19cb71432825ddead7754","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
